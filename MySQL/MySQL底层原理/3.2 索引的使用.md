## 1. 索引用于查询

对于一条查询语句

1. 找到查询语句所有的可用索引
2. 对于每一个索引，通过搜索条件，找出其扫描区间（对于一个索引，找到其扫描区间后，我们只要找到扫描区间内的第一条记录，然后沿着记录的单向链表向后扫描，直到遇到不符合条件的记录）

## 2. 索引用于排序

* **filesort**——在内存中进行排序or数据太多，内存放不下，借助磁盘存放中间结果的排序

* 合理使用索引——可以减少排序带来的消耗

* **使用联合索引进行排序**
  
  * 如果使用联合索引进行排序——order by后面的列的顺序要与联合索引的顺序一致，如果不一致就无法使用联合索引来排序
  * 使用联合索引进行排序要遵守最左前缀匹配原则，如果违反了最左前缀匹配原则，就无法使用联合索引来排序
  * 使用到的联合索引的各个列的排序规则要一致（要么都升序，要么都降序），否则无法使用搜索排序

* **无法使用索引进行排序的情况**
  
  * 如果用来排序的多个列不属于同一个索引，那么也不能使用索引进行排序
  * 用于形成扫描区间的列跟排序列不同
  * 如果排序列不是以单独的列名出现在 order by后，也无法使用索引排序

## 3. 索引用于分组

* 分组不通过索引——MySQL会建立一个用于统计的临时表，在扫描聚簇索引记录时将统计的中间结果写入该临时表，当扫描结束后，将临时表中的内容发送给客户端
* 使用索引进行分组，就不需要创建这个临时表了

## 4. 回表的代价

对于一条查询条件中使用了二级索引列的SQL，有2种方式

1. 全表扫描
2. 走二级索引，对于每一条二级索引记录进行回表

InnoDB会让同一个索引的叶子节点的页号尽可能靠近——这里可以通过顺序IO读取，效率更高

所以对于全表扫描，可以采用顺序IO读取到所有的记录

对于走二级索引，可以通过顺序IO读取到符合条件的二级索引记录，对于每一条二级索引记录，都需要回表一次，由于二级索引记录的主键值是无规律的，这些二级索引回表时，查询的主键值不连续，所以回表采用随机IO，性能低

**所以，如果走二级索引需要回表的次数过多，那么就不会走二级索引，而是走全表扫描**

```sql
select * from table where key1>'a' AND key1<'c' limit 10; //限制10条——走二级索引
select * from table where key1>'a' AND key1<'c'; //没有做限制，查询的数据量很大，走全表扫描
```

## 5. 使用索引技巧

### 5.1 为用于搜索，排序和分组的列创建索引

### 5.2 考虑索引列中不重复值的个数

在通过二级索引+回表查询时，某个扫描区间如果包含的二级索引记录数量越多，会导致回表操作的代价越大

所以我们需要考虑该列中不重复值的个数，如果太少了，那么可能导致回表过多

### 5.3 索引失效的情况

1. 左模糊匹配or左右模糊匹配

2. 对索引列使用函数

3. 对索引列进行表达式计算

4. 联合索引的使用不符合最左前缀匹配原则

5. WHERE子句中，OR前的条件列是索引列，OR后的条件列不是索引列

6. 查询条件中使用两个列做比较

7. 查询条件中使用不等于进行比较

8. order by导致索引失效