#  1. CAP理论

一个分布式系统不可能同时满足**一致性**，**可用性**，**分区容错性**，最多只能**同时满足其中的两项**

* **一致性C**

  客户端的每次读操作，不管访问哪个节点，要么读到的都是同一份最新的数据，要么读取失败（强调的是各节点之间的数据一致，而不是数据完整）

* **可用性A**

  系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够**在有限的时间**内返回结果，但不保证每个节点都能返回最新的数据

* **分区容错性P**

  节点间出现任意数量的消息丢失or高延迟or分区故障的时候，系统仍然可以继续提供服务，强调的是集群对分区故障的容错能力



## CAP理论的使用

* **P是必须满足的**——因为只要是网络交互就一定有延迟和消息丢失，并且节点间的分区故障是必然发生的
* **在分布式系统正常运行时**，我们不需要P，C和A可以同时保证
* **当分布式系统发生分区故障时**，我们需要P，此时需要在A和P之间做出选择
  * **选择C**——当发生分区故障时，消息丢失，此时无法保证所有节点的数据都是最新的，那么这个时候，集群如果接受到了来自客户端的写请求，会返回失败错误，拒绝新数据的写入
  * **选择A**——当发生分区故障时，集群始终会处理客户端的请求，但是访问不同的节点可能得到不同的数据



## CAP理论的具体应用

* CA模型——舍弃P就是舍弃分布式系统，比如单机版的MySQL
* CP模型——一旦消息丢失，高延迟，分区故障，那么会影响用户体验和业务的可用性（Zookeeper，Etcd，HBase）
* AP模型——实现服务的高可用，当出现分区故障时，访问不同的节点可能会得到不同的数据（Cassandra，DynamoDB）



## AP和CP的实现

* CP——Raft或者ZAB
* AP——Quorum NWR，Gossip



# 2. ACID理论

* ACID理论是CAP理论中CP的延伸，**ACID追求强一致性模型，是最强的一致性**

* **分布式系统要实现ACID**——依靠**分布式事务协议**
  * 2PC
  
  * 3PC

  * TCC
  
  * 基于消息补偿的最终一致性
  
    	1. 服务A先把消息持久化到本地数据库，并把状态设为待发送；
    	2. 服务A把消息发送到消息队列当中；
    	3. 服务B从消息队列获取消息并执行；
    	4. 服务B如果执行成功，则发送一个消息到消息队列响应服务A，如果失败，则不操作；
    	5. 服务A从消息队列获取响应结果；
    	6. 更改本地数据库对应的消息状态，改为完成；
    	7. 有一个定时任务，从本地数据库查找消息状态为未完成的，并重新投递到消息队列当中。
  
* Paxos，Raft等强一致算法，也采用了二阶段提交，但是在其只需要过半节点确认即可，而两阶段提交需要全部节点确认，所以具有ACID特性的操作，可以理解为拥有最强的一致性

* **2PC与TCC的区别**

  * TCC的本质是补偿事务
  * TCC核心思想——对于每个操作都要注册一个对应的确认操作和补偿操作（撤销操作）
  * TCC是业务层面的协议，TCC的3个操作都要在业务代码中编写，为了实现一致性，确认操作和补偿操作必须是幂等的
  * TCC不依赖数据库的事务，在业务中实现的分布式事务，避免对资源的长时间占用——减轻了数据库的压力，但是对业务代码侵入性较强，效率比较高
  * 2PC 是数据库或者存储资源层面的事务，实现的是强一致性，在两阶段提交的整个过程中，一直会持有数据库的锁
  * **TCC通过补偿机制来完成整个业务操作，保证最终一致性**，**2PC是强一致性的**



# 3. BASE理论

* **BASE理论是CAP理论中AP的延伸，强调高可用性**
* BASE是A和C权衡的结果，通过牺牲强一致性获得基本可用性——在NoSQL，微服务架构中应用广泛

* Basically Available(基本可用)，Soft state(软状态)，Eventually consistent(最终一致性)

* **核心思想**

  如果不是必须的话，不推荐实现事务或者强一致性，鼓励可用性和性能优先，根据业务的场景特点，来实现弹性的基本可用，努力保障极端情况下的系统可用性

* **基本可用**

  分布式系统出现故障时，允许损失部分可用性，保障核心功能的可用性（例如通过服务降级，流量削峰，延迟响应，过载保护）

* **软状态**

  存在软状态——业务操作没有最终完成前的中间状态

  > 例如：整个业务流程是：顾客下单—创建订单—发送短信
  >
  > 创建订单后我们就告诉顾客操作成功，但此时业务操作还没有最终完成，这就是软状态

* **最终一致性**

  系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态（不需要实时保证系统数据的强一致性）

  * 如果业务补发容忍一致性的延迟，就应该用强一致性
  * 如果业务能短暂容忍一致性的延迟，就可以考虑最终一致性





## 3.1 最终一致性实现方法

* 读时修复：在读取数据时，检查数据的不一致情况，进行修复（查询时，检测不同节点的副本数据是否一致）
* 写时修复：在写入数据时，检查数据的不一致情况，进行修复（节点之间进行写操作同步时，如果失败了，就将写操作缓存下来，定时重传）——对性能消耗下，用户写操作只需要对一个实例写，该实例会负责将这个写操作同步给其他实例，建议优先考虑
* 异步修复：定时对不同副本的数据进行校对，如果不一致就修复