### 1. 2PC
* 一阶段:Prepare（意义：预留锁定资源）
  * 事务协调者发送Prepare给所有的事务参与者
    * 所有的参与者返回Yes——进入二阶段Commit
    * 有任何一个参与者返回No或者超时——进入二阶段Rollback
* 二阶段:Commit或Rollback
  * 事务协调者向所有的事务参与者发送Commit/Rollback
  * 进入二阶段，事务参与者即使宕机，也要保证重启后再次收到二阶段指令时可以正确执行

* 蚂蚁实现了"二阶段异步化"
  * 进入二阶段后，事务协调者就可以向Client返回业务结果。二阶段异步去处理（由某些机制去保证所有的参与者一定会执行完二阶段）
  * 开启二阶段异步化，客户无法实时感知分支事务的状态，需要进行一些改造确保对外的业务语义是用户可接受的

* 二阶段存在的问题
  * 同步阻塞：事务参与者执行完一阶段后，如果事务协调者宕机，那么事务参与者阻塞，并一直锁定资源
  * 数据一致性问题：二阶段可能出现一部分事务参与者收到二阶段命令，另一部分事务参与者没收到，会导致数据不一致
### 2. TCC

TCC是服务层的2PC实现，本质是一种补偿事务，通过补偿机制保证数据的最终一致性。
TCC对业务理解的要求高，对基础组件的要求低。
* 事务协调者
* 事务参与者（要求提供事务参与者提供3个业务接口，3个接口都必须是幂等的）
  
  * try
  
  * confirm
  
  * cancel

#### TCC在蚂蚁的实现
蚂蚁的XTS框架将协调者拆分为了xts-client与xts-server两部分
* xts-client负责维护事务数据与流程控制
* xts-server负责异常事务的恢复，二阶段异步化

1. 使用上一般将xts-client合并到一个参与者上,该参与者A开启事务模板（开启分布式事务）,自己的prepare操作就是在该事务模板中执行的业务SQL，并且会在事务模版中调用其他参与者的prepare接口  
2. 如果事务模版执行完最后一行代码，那么就代表所有参与者的prepare都完成，分布式事务进入二阶段Commit。如果在事务模版中有未被捕获的异常抛出，那么参与者A自己的业务SQL会回滚，分布式事务进入二阶段Rollback。  
3. 二阶段由xts-server保证所有的参与者都成功执行完commit/rollback。 

为了实现分布式事务，需要由2张核心的表
* 主事务记录表（主事务id,主事务状态）
* 分支事务记录表（分支事务id，分支事务状态）

### 3. FMT
FMT是数据访问层的2PC实现，为了解决2PC放在服务层实现的痛点，让业务不感知。在SQL提交层面实现一阶段SQL语句锁定需要的资源，二阶段让SQL执行结果真正对外部可见

### 4. XA
XA书数据库层的2PC实现，需要使用符合XA规范的数据库 
1. 开启分布式事务
2. 执行SQL
3. 正常执行就Commit，抛异常Rollback


### 5. 3PC
将2PC的Commit拆为canCommit,preCommit
2PC的Commit——>doCommit
* 优点
  * 介绍阻塞范围（只会preCommit有阻塞问题）
  * 事务参与者引入超时机制，参与者没有及时收到preCommit会自动回滚，没有及时收到doCommit回自动提交
* 缺点
  * 阻塞问题仍然存在
  * 数据不一致问题仍存在