## 1. 僵尸进程和孤儿进程

* 僵尸进程：进程使用fork创建子进程，子进程退出，父进程并没有调用wait或waitpid去回收子进程，那么子进程的进程描述符仍然存在

* 孤儿进程：父进程退出，子进程仍在运行，子进程会被init进程锁收养

* 危害——孤儿进程被init进程收养，不会有什么危害，但是僵尸进程会占用进程号，占用系统资源，僵尸进程一定要处理

* 如何避免
  
  * 父进程一定要手动通过wait或者waitpid等待子进程结束去回收子进程
  
  * 通过信号机制
    
    * 人工kill
    
    * 父进程中加入一条语句：signal(SIGCHLD,SIG_IGN);表示父进程忽略SIGCHLD信号，子进程结束时会向父进程发送SIGCHILD信号，父进程忽略SIGCHILD信号，那么内核会处理，把僵尸子进程转交给init进程去处理

## 2. wait和waitpid区别

* wait是让父进程等待子进程结束，当子进程结束后回收其资源

* waitpid回收指定进程号的子进程，可以设置为阻塞/非阻塞
  
  * pid>0：具体某个子进程
  
  * pid=0：回收当前进程组中所有的子进程
  
  * pid=-1：回收所有子进程，相当于wait
  
  * pid<-1：进程组的组id的绝对值，回收指定进程组中的所有子进程

## 3. 大端序和小端序

* 大端序：数据的低位字节存放在高位地址，高位字节存放在低位地址

* 小端序：数据的低位字节存放在低位地址，高位字节存放在高位地址

小端序广泛应用于CPU内部存储数据，网络传输，文件存储使用大端序（因为大端序符合人类的阅读习惯，小端序更符合CPU读取数据的方式，CPU读取内存数据时，从低地址向高地址读取）

## 4. 一个程序从编译到运行全过程

1. **编译**：编译器将程序代码编译成汇编代码

2. **汇编**：汇编器将汇编代码翻译为二进制的机器码

3. **链接**：链接器会将一个个目标文件和库文件链接在一起，形成一个可执行文件

4. **载入**：加载器将可执行文件的代码和数据从磁盘加载到内存中，跳转到程序第一条指令处开始执行
