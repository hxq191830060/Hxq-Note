## 1. 调度分类

* **非抢占式调度**——挑选⼀个进程，然后让该进程运⾏直到被阻塞，或者直到该进程退出，才会调⽤另外⼀个进程，也就是说不会理时钟中断这个事情

* **抢占式调度**——挑选⼀个进程，然后让该进程只运⾏一段时间，如果在该时段结束时，该进程仍然在运⾏时，则会把它挂起，接着调度程序从就绪队列挑选另外⼀个进程



## 2. 调度原则

1. **CPU利用率**——如果运行的程序发生了IO事件的请求，那么CPU的利用率必定很低，因为此时进程在阻塞等待硬盘的数据返回，所以为了提高CPU利用率，在这种发生IO事件致使CPU空闲的情况下，调度程序需要从就绪队列中选择一个进程来运行
2. **系统吞吐量**——调度程序要权衡长任务和短任务的运行时间和运行完成数量
3. **周转时间**——调度程序要避免一个进程等待时间很长而运行时间很短
4. **等待时间**——调度程序要考虑进程在就绪队列里面的等待时间
5. **响应时间**——对于交互式比较强的应用，响应时间是需要考虑的



## 3. 调度算法

### 3.1 非抢占式FIFO

* 每次从就绪队列中选择最先进入队列的进程，然后一直运行，直到进程退出或者进程被阻塞，才会选择下一个进程

![23](p\23.png)

### 3.2 非抢占式最短任务优先

CPU先运行需要时间最短的任务，运行结束后，切换到次短的任务

![SJF、](p\SJF、.png)

### 3.3 非抢占式高响应比优先

* 每次进行进程调度时，先计算响应比优先级，然后把响应比优先级最高的进程进行调度

![24](p\24.png)

### 3.4 抢占式最短任务优先

在SJF的基础上添加抢占

每当新工作进入系统时，会确认剩余工作和新工作剩余所需的时间，谁剩余的时间少，就调度他

![STCF](p\STCF.png)



### 3.5 抢占式时间片轮转

* 以时间片为单位，在一个时间片内运行一个进程，时间片耗尽后，切换到下一个进程
* 时间片必须是时钟中断周期的整数倍

![25](p\25.png)





### 3.6 抢占式多级反馈队列

* **目的：优化周转时间和响应时间**

* MLFQ分为多个队列，每个队列都有不同的优先级

* 一个任务在某一时刻，只能处于一个队列中

  ![MLFQ](p\MLFQ.png)

* 五条规则

  1. 优先调度高优先级队列中的进程
  2. 同一个优先级队列中的进程轮转段杜
  3. 任务进入系统时，放在最高优先级队列
  4. 每个队列都有一个时间配额，调度程序会计算一个进程在一个队列中消耗的时间，一旦某个进程耗尽了在该队列的时间配额，就会降低优先级（进入优先级低一级的队列）
  5. 经过一段时间S，将系统中的所有工作都放入最高优先级的队列

* 计算密集任务的优先级会迅速下降，如果此时又来了非常多的交互任务，那么计算密集任务就可能会饿死，**第4条和第5条规则就是为了防止进程饿死**

