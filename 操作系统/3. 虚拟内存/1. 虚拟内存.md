# 1. 虚拟内存介绍

* OS为每个进程分配**独立的虚拟内存（地址空间）**，**进程看到的都是虚拟内存**，无法看到物理内存，各个进程只能访问自己的虚拟内存
  
  ![9](p/9.png)

* OS提供一种机制，将不同进程的**虚拟地址**和**物理地址**映射起来（需要借助硬件MMU）
  
  ![10](p/10.png)

## 虚拟内存的作用

1. 为进程提供独立的内存空间，简化内存管理

2. 保护每个进程的地址空间不会被其他进程破坏

3. 控制进程对物理内存的访问，对不同权限的进程进行隔离，提供安全性

4. 虚拟内存可以利用物理内存起到缓存的作用，提供对磁盘数据的访问速率

# 2. OS管理虚拟地址与物理地址的映射

## 2.1 动态重定位

* 将程序的全部地址空间映射到一整块完整的物理内存上

![动态重定向.drawio](p/动态重定向.drawio.png)

* **CPU需要两个寄存器——基址寄存器+界限寄存器**
  
  **物理地址=虚拟地址+基址寄存器的值**

* **界限寄存器**——提供访问保护，有2种模式
  
  1. 记录最大允许访问的虚拟地址，如果虚拟地址超过该值，CPU会触发异常
  2. 记录最大允许访问的物理地址，如果虚拟地址转换后的物理地址超过该值，CPU会触发异常

* **动态**——进程暂停运行时，OS可以改变程序地址空间对应的物理内存的位置
  
  * 将进程地址空间对应的物理内存的内容拷贝到新的位置
  * 更改保存的基址寄存器的值（保存在进程结构中）

* **动态重定位的缺点**——OS为进程的地址空间在物理内存分配了一块同等大小的连续的内存，即使是地址空间中还未使用到的内存都会在物理内存中分配，这就导致物理内存中有大量的空间没有使用，被浪费了——**内部碎片**

## 2.2 分段

* 将程序划分为若干个逻辑段（代码段，数据段，栈段，堆段），每个段在物理内存中占用一块连续完整的内存

* 虚拟地址通过**段表**与物理地址进行映射

* **硬件支持**—— **段表寄存器**——存储段表的起始地址和段表的长度

* 虚拟内存分为2个部分——段选择因子+段内偏移量

![分段.drawio](p/分段.drawio.png)

* 分段有2个不足之处
  * 内存碎片问题
  * 内存交换效率低的问题

### 2.2.1 分段缺点—内存碎片

![分段内存碎片](p/分段内存碎片.png)

* **外部内存碎片**——物理内存中产生了多个不连续的小物理内存块，这个小的物理内存块很难被其他程序使用
* **内部内存碎片**——程序的内存装载到物理内存中，这个程序的内存中可能有一部分是未被使用的，但还是在物理内存中占用了空间

### 2.2.2 分段缺点—内存交换效率低

内存交换是用来解决外部内存碎片问题的

Linux在硬盘上划分了一个内存交换空间（Swap空间），用于内存与硬盘的空间交换——通过Swap空间，可以让物理内存中使用的内存更加紧凑

但是磁盘的访问速度比内存慢，所以将一大段连续的内存写到磁盘上是很耗时的

## 2.3 分页

* 分页将虚拟内存和物理内存都划分为一个个固定尺寸的大小（页，4KB）
* 虚拟地址和物理地址之间通过**页表**来映射
* **硬件支持**——需要**页表基址寄存器**来记录页表的起始物理地址和页表长度
* 页表存储在内存中，内存管理单元MMU负责将虚拟地址转换为物理地址
* **页表占用的存储空间**——假设32位的地址空间，那么20位是虚拟页号，12位是页内偏移量，那么就有2^20个虚拟页，页表中需要有2^20个页表项——每个进程都有自己的一个页表，页表是保存在内存中的，需要一整块连续的物理内存来存储（问题：页表占用内存过多）

![分页机制.drawio](p/分页机制.drawio.png)

* 采用了分页，释放内存时以页为单位，不会产生无法给进程使用的小内存
* 分页机制——允许我们在加载程序时，不需要一次性把程序都加载到物理内存中，可以在完成虚拟内存与物理内存的映射之后，将不需要使用到的指令和数据存储在磁盘上，需要的时候再加载到内存中

### 2.3.1 页表项结构

页表由一个个页表项组成，通过**虚拟页号**可以在页表中找到对应的页表项，**页表项由物理页号和一些列的标志位组成**

![页表项](p/页表项.png)

* **PFN(Page Frame Number）**：物理页号
* **P(Present)**：有效标志
  * 1：有效，页表项对应的页，它的数据存储在物理内存上，PFN是其物理页号
  * 0：无效，页表项对应的页，它的数据不在物理内存上（可能在磁盘上），访问无效的页表项会抛出**缺页中断**，并且此时页表项的其余位可供程序自由使用（例如，可以用其余位来表示数据在Disk上的地址）
* **R/W(Read/Write)：**读写标志
  * 1：页面可以被读，写，执行
  * 0：页面只读或可执行
* **U/S(User/Supervisor)**：用户/超级用户标志
  * 1：运行在任何特权级上的程序都可以访问该页表项对应的页面
  * 0：页表项对应的页面只能被运行在超级用户特权级上的程序访问
* **A(Access)**：访问标志——用于追踪页面的访问情况
* **D(Dirty)**：脏位——页是否被修改过

### 2.3.2 only分页下的数据访问过程

1. 从虚拟地址中获得**虚拟页号**和**页内偏移量**
2. 从页表基址寄存器中获得**页表的起始物理地址**，计算出目标页表项的物理地址
3. 从页表中取出对应的页表项
4. 从页表项中读出物理页号，通过物理页号与页内偏移量计算得到物理地址
5. 通过物理地址访问物理内存

### 2.3.3 分页的缺点

分页带来了以下2个问题

* 在访问物理内存前，需要多访问一次页表进行地址转换——**通过TLB优化**
* 每个进程都有一个页表，并且页表存储在内存中，占用内存大——**采用段页式or多级页表优化or反向页表**

# 3. 分页优化

## 3.1 TLB

* TLB——用于存放**页表项**的Cache（采用全相联映射）

![TLB](p/TLB.png)

### 3.1.1 分页+TLB的数据访问过程

1. 从虚拟地址取出虚拟页号
2. 根据虚拟页号在TLB中查找页表项（硬件会并行地查找TLB）
3. 如果**TLB命中了**，那么从页表项中取出物理页号，计算出物理地址，访问
4. 如果**TLB未命中**，从页表基址寄存器中取出页表的起始物理地址，根据虚拟页号计算目标页表项的物理地址
5. 取出页表项，将页表项插入TLB中
6. 重复上述操作（此时TLB中存在该页表项，可以直接从TLB中取得）

### 3.1.2 TLB加速的原因

* **时间局部性**——最近访问过的指令或数据项很快会再次被访问

* **空间局部性**——访问访问内存地址x时，可能很快会访问地址x附近的内存

* **TLB的成功依赖于空间局部性和时间局部性**

* 得益于空间局部性，数据中的元素存储在连续的几页，因此只有对页中第一个元素的访问才会导致TLB未命中，页中的其他元素的访问会TLB命中

* 得益于时间局部性，短时间内程序可能会再次访问内存页，导致TLB命中率很高

### 3.1.3 TLB如何支持多进程

TLB包含的TLB项中的虚拟地址到物理地址的映射只对当前进程有效，需要有一个机制来保证进程上下文切换后，不会误读TLB，有以下两种方案

* 上下文切换时，清空TLB
* 在TLB项中添加一个 **地址空间标识符ASID（Address Space Identifier）**，用来标识TLB项可以让哪个进程使用

## 3.2 多级页表

![13](p/13.png)

* 将二级页表也切分成固定大小的单元（二级页表页）
* 一级页表中，一个一级页表项对应一个二级页表页
* 如果一个一级页表项是无效的——那么该一级页表项对应的二级页表页中的所有二级页表项都是无效的（不需要分配内存）
* **好处**
  * 没有使用的二级页表页不需要分配内存，只需要在其对应的一级页表项中标记为无效即可，节约内存
  * 二级页表以页为单位进行组织，更容易管理，并且二级页表不需要占用一整块连续的内存，可以将二级页表中不同的页表页放在物理内存上的不同位置

#### 64位系统使用四级页表

* **全局页目录项(Page Global Directory) PGD**
* **上层页目录项(Page Upper Directory) PUD**
* **中间页目录项(Page Middle Directory) PMD**
* **页表项(Page Table Entry) PTE**

![14](p/14.png)

## 3.3 段页式

* 先将程序划分为多个有逻辑意义的段

* 将每个段划分为多个页

* 每个段都有一个页表

* 虚拟地址由**段号**，**段内页号**，**页内偏移量**三部分组成
  
  ![段页式虚拟地址](p/段页式虚拟地址.png)

![15](p/15.png)

## 3.4 反向页表

* 所有进程共用一个页表
* 页表项记录了哪个进程正在使用对应的物理页，以及该进程的哪个虚拟页映射到该物理页
* 可以在反向页表的基础上建立散列表，加快查询

# 4. Swap

* OS允许在物理内存不够用的时候，将一些暂时用不到的内存数据交换到磁盘上，需要时再从磁盘加载到内存上
* 通过Swap，让程序看到的内存视图很大，甚至超过了物理内存，OS可以为多个进程都提供巨大的地址空间的假象

## 4.1 页表项对Swap的支持

页表项中有一个有效标志位

**P(Present)**：有效标志

* 1：有效，页表项对应的页的数据存储在物理内存上，PFN是其物理页号
* 0：无效，页表项对应的页的数据不在物理内存上（可能在磁盘上），访问无效的页表项会抛出**缺页中断**，并且此时页表项的其余位可供程序自由使用（例如，可以用其余位来表示数据在Disk上的地址）

一旦发生缺页中断，OS的**缺页中断处理程序**会处理缺页中断

## 4.2 OS的缺页中断处理程序

1. 从导致缺页中断的无效的页表项中获得Disk Address，在磁盘中找到目标页面的位置

2. 找到一个空闲的物理页
   
   如果不存在空闲的物理页，根据**内存页面置换算法**，选择一个可被替换的物理页，将该物理页刷盘，然后将该页对应的页表项的有效位设置为0，并填充其磁盘地址

3. 将数据从磁盘换入空闲的物理页

4. 更新页表项（修改页表项的有效标志位，物理页号）

## 4.3 分页+Swap的数据访问过程

![16](p/16.png)

1. 在 CPU 访问执行一条读指令， 会去找查找数据所在页对应的⻚表项

2. 如果该⻚表项的状态位是「有效的」，那 CPU 就可以计算得到物理内存进行访问了，如果状态位是「⽆效的」，那么抛出缺页中断

3. OS收到了缺页中断，执行缺页中断处理程序，首先从页表项中获得Disk Address，在磁盘中找到目标页面的位置

4. 找到一个空闲的物理页
   
   如果不存在空闲的物理页，根据**内存页面置换算法**，选择一个可被替换的物理页，将该物理页刷盘，然后将该页对应的页表项的有效位设置为0，并填充其磁盘地址

5. 将数据从磁盘换入空闲的物理页

6. 更新页表项（修改页表项的有效标志位，物理页号）

7. CPU 重新执⾏导致缺⻚中断的指令

# 5. 内存页面置换算法

## 5.1 最佳页面算法(OPT)

基本思路是，**置换在「未来」最⻓时间不访问的⻚⾯**——理想化算法

## 5.2 先进先出算法(FIFO)

## 5.3 LRU

发⽣缺⻚时，选择最⻓时间没有被访问的⻚⾯进⾏置换

**实现**

增加硬件支持——硬件在每个页访问时更新页的时间字段，在替换页时，OS扫描所有页的时间字段找到最近最少使用的页

* **缺点**——扫描所有的页需要消耗很多的时间

## 5.4 时钟算法

近似LRU

* 增加硬件支持——每个页增加一个使用位，当页被使用时，硬件将使用位设置为1，该位的清0操作由OS负责

* 系统中所有的页都放在一个循环列表中，时钟指针开始指向某个特定的页，当进行页替换时，OS检查指针指向的页的使用位，如果是1，那么表示该页最近被使用，让其使用位设置为0，然后移动指针到下一个页；如果是0，那么表示该页最近都没有被使用，移除掉该页

## 5.5 LFU

* 当发⽣缺⻚中断时，选择「访问次数」最少的那个⻚⾯，并将其淘汰

* 实现方式——对每个⻚⾯设置⼀个「访问计数器」，每当⼀个⻚⾯被访问时，该⻚⾯的访问计数器就累加 1，在发⽣缺⻚中断时，淘汰计数器值最⼩的那个⻚⾯

# 6. 分页+TLB+Swap的数据访问过程

![分页+TLB+Swap数据访问.drawio](p/分页+TLB+Swap数据访问.drawio.png)

# 7. Linux内存管理

## 7.1 Linux内存机制

* Linux内存主要采用页式内存管理，同时涉及到了段机制

* Linux系统中的每个段都是从0地址开始的整个4GB虚拟空间

* 在Linux中，虚拟地址空间内部又划分为内核空间和用户空间，默认是将高地址的1G空间分配给内核
  
  ![17](p/17.png)

* 每个进程都有自己独立的虚拟内存，但是每个进程的虚拟内存中的内核空间，关联的是相同的物理内存
  
  ![18](p/18.png)
  
  ## 7.2 Linux内存布局
  
  ![Linux中进程的内存布局.drawio](p/Linux中进程的内存布局.drawio.png)
