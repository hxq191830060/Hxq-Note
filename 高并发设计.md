## 不足的几类做法

1. 对数据化的指标没有概念——不清楚选择什么样的指标来衡量高并发系统？分不清并发量和QPS，甚至不知道自己系统的总用户量，活跃用户量，平时和高峰时的QPS和TPS

2. 设计了一些方案，但是细节掌握不透彻——讲不出方案关注的技术点和可能带来的副作用（例如读性能有瓶颈会引入缓存，但是忽视了缓存命中率，热点key，数据一致性等问题）

3. 理解片面，把高并发设计等同于性能优化——大谈并发编程，多级缓存，异步化，水平扩容，却忽视了高可用设计，服务治理和运维保障

4. 掌握大方案，却忽视最基本的问题——能讲清楚垂直分层，水平分区，缓存等大思路，却没意识到数据结构是否合理，算法是否高效，没想过从最根本的IO和计算两个维度去做细节优化





## 如何理解高并发

高并发系统设计的目标有三个——高性能，高可用，高可拓展



### 高性能实践方案

1. 集群部署，通过负载均衡减轻单机压力。

2. 多级缓存，包括静态[数据](/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE)使用CDN、本地缓存、分布式缓存等，以及对缓存场景中的热点key、缓存穿透、缓存并发、[数据](/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE)一致性等问题的处理。

3. 分库分表和索引优化，以及借助搜索引擎解决复杂查询问题。

4. 考虑NoSQL[数据](/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE)库的使用，比如HBase、TiDB等，但是团队必须熟悉这些组件，且有较强的[运维](/jump/super-jump/word?word=%E8%BF%90%E7%BB%B4)能力。

5. 异步化，将次要流程通过多线程、MQ、甚至延时任务进行异步处理。

6. 限流，需要先考虑业务是否允许限流（比如秒杀场景是允许的），包括前端限流、Nginx接入层的限流、服务端的限流。

7. 对流量进行削峰填谷，通过MQ承接流量。

8. 并发处理，通过多线程将串行逻辑并行化。

9. 预计算，比如抢红包场景，可以提前计算好红包金额缓存起来，发红包时直接使用即可。

10. 缓存预热，通过异步任务提前预热[数据](/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE)到本地缓存或者分布式缓存中。

11. 减少IO次数，比如[数据](/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE)库和缓存的批量读写、RPC的批量接口支持、或者通过冗余[数据](/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE)的方式干掉RPC调用。

12. 减少IO时的[数据](/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE)包大小，包括采用轻量级的通信协议、合适的[数据](/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE)结构、去掉接口中的多余字段、减少缓存key的大小、压缩缓存value等。

13. 程序逻辑优化，比如将大概率阻断执行流程的判断逻辑前置、For循环的计算逻辑优化，或者采用更高效的[算法](/jump/super-jump/word?word=%E7%AE%97%E6%B3%95)。

14. 各种池化技术的使用和池大小的设置，包括HTTP请求池、线程池（考虑CPU密集型还是IO密集型设置核心参数）、[数据](/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE)库和Redis连接池等。

15. JVM优化，包括新生代和老年代的大小、GC[算法](/jump/super-jump/word?word=%E7%AE%97%E6%B3%95)的选择等，尽可能减少GC频率和耗时。

16. 锁选择，读多写少的场景用乐观锁，或者考虑通过分段锁的方式减少锁冲突。



### 高可用实践方案

1. 对等节点故障转移，Nginx和服务治理框架要支持访问一个节点失败后，访问另一个节点

2. 非对等节点故障转移，通过心跳检测并进行主备切换

3. 接口层面的超时设置，重试策略，幂等设计

4. 服务降级，必要时进行熔断

5. 限流处理

6. MQ消息可靠性保证

7. 灰度发布，支持按机器维度进行小流量部署，观察系统日志和业务指标，等运行平稳后再推全量

8. 监控报警：全方位的监控体系

9. 灾备演练，对系统进行一些破坏性手段，观察局部故障是否会引起可用性问题





### 高拓展实践方案

1. 合理的分层架构

2. 存储层的拆分：按照业务维度做垂直拆分，按照数据特征维度进一步做水平拆分（分库分表）

3. 业务层的拆分：按照业务维度拆分，也可以按照核心接口和非核心接口拆分


