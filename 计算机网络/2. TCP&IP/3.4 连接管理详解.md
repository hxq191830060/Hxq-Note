# 1. 总览

## 1.1 全过程

![49](p/49.png)

## 1.2 全连接队列和半连接队列

Linux内核为ServerSocket维护两个队列——全连接队列，半连接队列

* 全连接队列的长度=min(`net.core.somaxconn`，listen()传入的backlog参数)

![50](file://D:\桌面\Hxq-Note\计算机网络\2. TCP&IP\p\50.png?msec=1658667402774)

* 第一次握手信息到达时，为其创建一个request_sock对象，插入半连接队列

* 第三次握手信息到达时，从半连接队列中移除对应的request_sock对象，创建一个新的request_sock对象，放入全连接队列
  
  > 如果全连接队列满了，有两种处理策略
  > 
  > 1. 丢弃掉第三次握手信息，但不通知Client
  > 
  > 2. 发送一个reset报文段给Client，表示废除该连接

# 2. 三次握手

![51](p/51.png)

## 2.1 listen()

* 进行半连接队列和全连接队列的长度限制计算，以及内存申请和初始化
  
  * 全连接队列——链表
  
  * 半连接队列——哈希表

## 2.2 connect()

1. 将Client的Socket状态更改为`SYN_SENT`

2. 动态选择一个可用的端口

3. 构建一个SYN报文，发送出去，同时启动一个重传定时器

## 2.3 Server处理第一次握手

1. 判断半连接队列是否满了，如果满了，判断内核是否开启了`tcp_syncookies`参数，如果没开启，就将包丢弃

2. 判断全连接队列是否满了，如果满了，也会将包丢弃掉

3. 创建一个request_sock对象，插入到半连接队列中，开启一个计时器，如果在规定时间内没有收到第三次握手，就会重传第二次握手信息

## 2.4 Client处理第二次握手

1. 清除connect()时设置的重传定时器

2. 修改Socket状态是`ESTABLISHED`

3. 初始化拥塞控制，打开TCP保活计时器

4. 发出第三次握手信息

## 2.5 Server处理第三次握手信息

1. 在半连接队列中查找对应的半连接对象

2. 创建新的sock对象

3. 清除半连接队列中旧的sock对象

4. 将新的sock对象添加到全连接队列中

5. 将连接状态设置为`Established`

## 2.6 accpet()

如果全连接队列不为空，那么就从全连接队列中取出第一个Socket返回，否则阻塞

# 3. 四次挥手

![52](p/52.png)