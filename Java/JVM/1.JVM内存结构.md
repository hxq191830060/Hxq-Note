# 0. JDK6的内存结构

![alt 属性文本](p/JVM内存结构.png)



# 1. 程序计数器

* 线程私有的一块很小的内存
* 如果执行的是Java方法，程序计数器存储的是下一条字节码指令的地址
  如果执行的是本地方法，程序计数器为Undefined



# 2. 虚拟机栈

## 2.1 概述

* **作用**——管理Java程序的运行，保存方法的局部变量，部分结果，参与方法的调用和返回
* 每执行一个Java方法，会往Java虚拟机栈中**push**一个栈帧；一个Java方法执行完毕（不管是正常执行完毕还是抛出异常），其对应的栈帧从Java虚拟机栈中**pop**
* 如果一个方法调用了其他方法，那么被调用方法返回时，会将执行结果传递给前一个栈帧，存储到前一个栈帧的操作数栈中，然后被调用方法的栈帧出栈
* 虚拟机栈的大小可以是动态的也可以是固定的
  * 如果让Java虚拟机大小固定——那么如果线程请求分配的栈空间超过了所允许的最大大小——抛出`StackOverflowError`
  * 如果让Java虚拟机大小动态——那么在无法申请到足够内存or新线程创建时没有足够的内存去创建对应的虚拟机栈——抛出`OutOfMemoryError`



## 2.2 栈帧

栈帧的内部结构如下

* 操作数栈
* 局部变量表
* 动态链接
* 返回地址
* 其他附加信息
  * 锁记录

### 2.2.1 操作数栈

* **操作数栈主要用于保存计算过程的中间结果，同时作为计算过程中的变量提供临时的存储空间**

* 在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（push）、出栈（pop）
* 32bit类型在操作数栈中占用1个栈单位深度，64bit类型占用2个
* 操作数栈所需的最大深度在编译期就确定下来了——保存在方法的Code属性的`max_stack`中
* 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中

>栈顶缓存技术——将栈顶元素缓存在物理CPU中，降低对内存的读写次数



### 2.2.2 局部变量表

* 存储方法参数和定义在方法体内的局部变量——包含了编译器可知的Java基本数据类型，reference，returnAddress类型
* 局部变量表中，最基础的存储单位为Slot——除了double和long占用两个连续的Slot，其他类型占用1个Slot
  * byte，short，char，boolean在存储前会被转换为int
  * 每个Slot都有一个访问索引，通过访问索引可以快速定位局部变量
  * 如果当前栈帧对应的方法是构造方法or实例方法，那么**对象引用this**存放在index为0的Slot处
* 局部变量表的大小在编译期就确定下来了——保存在方法的Code属性的`maximum local variables`中



### 2.2.3 动态链接

* 一个指向运行时常量池中该栈帧所属的方法的引用，该引用是为了支持方法调用过程中的动态连接
* Java源文件编译为class文件时，所有的变量和方法引用都是作为符号引用保存在class文件的常量池中，动态链接的作用就是将符号引用转换为调用方法的直接引用

>JVM如何执行方法调用？
>
>class文件的编译过程不包括传统编译器中的连接步骤，一切方法调用在class文件中存储的都是符号引用，而不是方法在内存中的入口地址(直接引用)——所以需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用
>
>* **静态链接**：一个class文件被载入JVM时，如果被调用的目标方法在编译器可知，且运行期保持不变，这种情况下符号引用转换为直接引用的过程就是静态链接
>* **动态链接**：如果被调用的方法在编译器无法被确定，只有在程序运行期间才能将调用方法的符号引用转换为直接引用，这称为动态链接

![动态链接](p/动态链接.jpg)



# 3. 本地方法栈

## 3.1 本地方法接口

* 一个 Native Method 就是一个 Java 调用非 Java 代码的接口
* Native Method存在的原因
  1. 与 Java 环境外交互：有时 Java 应用需要与 Java 外面的环境交互
  2. 与操作系统交互：JVM 支持 Java 语言本身和运行时库，但是有时仍需要依赖一些底层系统的支持。通过本地方法，我们可以实现用 Java 与实现了 jre 的底层系统交互， JVM 的一些部分就是 C 语言写的

## 3.2 本地方法栈

* 跟Java虚拟机栈相似，不同的是Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用
* 调用一个本地方法时，现在本地方法栈登记本地方法，然后在执行引擎执行时加载本地方法库



# 4. 堆

## 4.1 内存划分

* 堆是用来存放对象实例的，几乎所有的对象实力和数据都会在堆分配内存
* 堆在逻辑上进行了划分
  * 年轻代（Eden+Survivor0+Survivor1）
  * 老年代
  * 永久代（JDK8后移除，改为元空间）

![堆划分](p/堆划分.jpg)



## 4.2 TLAB

虽然堆是线程共享的，但是每个线程可以在堆（Eden）中划分出 **线程私有的分配缓冲区(Thread Local Allocation Buffer)**，线程就可以在自己的TLAB上创建对象，避免了线程安全问题



# 5. 方法区

* **Class对象(该类的方法区中各种数据的访问入口，各种数据包含了以下信息)**  
* **运行时常量池(内含字符串常量池)** 
  存放各种字面常量，class文件中的符号引用，以及符号引用解析得到的直接引用  
* **类型信息**
  类型的全限定名，类型父类的全限定名，类型实现的接口的全限定名，类型是类还是接口，类型的访问修饰符等
* **field信息**
  类中声明的所有字段(包括静态变量和实例变量，不包括局部变量)的描述(名称，类型，修饰符等)  
* **方法信息** 
  方法的名称，返回类型，参数表，**字节码指令**，修饰符，局部变量表和操作数栈的大小，异常表  
* **静态变量**   
* **指向类加载器的引用**  
* **指向Class类对象(Class.forName()的Class)的引用**  





# 6. 堆,方法区和栈的交互关系

![堆，方法区，栈交互关系](p/堆，方法区，栈交互关系.png)







# 7. 直接内存

直接内存并不属于运行时数据区

JDK1.4引入NIO类，引入了一种基于Channel与Buffer的I/O方式，可以使用Native函数库直接分配堆外内存(在直接内存中分配空间)，然后通过一个存储在堆中的DirectByteBuffer对象作为这块内存的引用进行操作
