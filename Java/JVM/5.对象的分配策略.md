**Java堆的内存模型**

<img title="" src="p/img_11.png" alt="alt 属性文本" width="692">

1. 对象优先分配在eden

2. 大对象直接进入老年代

3. 长期存活的对象进入老年代 
   JVM给每个对象定义了一个年龄计数器(Age)，存储在对象头中，对象每经历一次MinorGC，Age+1，当Age达到一个定值（默认15），进入老年代

4. 动态年龄判定 
   Survivor区中相同年龄的对象，如果其大小之和占到了 To Survivor区一半以上的空间，那么大于此年龄的对象会直接进入老年代   

5. MinorGC时，无法放入Survivor的对象进入老年代

6. **空间分配担保**   
   发生Minor GC前，JVM先检查老年代最大可用的连续空间 是否> 新生代所有对象总大小
   
   * 如果大于，那么这次Minor GC安全
   
   * 如果不成立，说明Minor GC不安全，JVM查看HandlePromotionFailure参数，查看是否允许担保失败
     
     * 如果允许，检查老年代最大可用的连续空间 是否> 历次晋升到老年代对象的平均大小  
       * 如果大于，进行一个Minor GC
       * 否则，进行一次FullGC  
     * 如果不允许，进行一次Minor GC
   
   * 为什么进行空间分配担保——是因为新生代采用**标记-复制算法**，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。**老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象**，但一共有多少对象在内存回收后存活下来是不可预知的，**因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考**。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。
