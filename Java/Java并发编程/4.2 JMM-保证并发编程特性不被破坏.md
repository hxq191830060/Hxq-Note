**为了保证并发编程的特性不被破坏，提供了以下几种模型**

## 1. 顺序一致性模型(非重点)

顺序一致性模型可以保证并发编程的特性不被破坏，为多线程程序提供了极强的 **内存一致性保证**

### 1.1 特点

* 一个线程中的所有操作必须按照程序的顺序来执行
* （不管程序是否同步）所有线程都只能看到同一个的操作执行顺序，**所有对内存的操作都是原子的，并且其他线程立即可见**
* 只有一个全局内存，某一时刻，**只有一个线程可以访问内存**，多线程并发时，**串行访问内存**

### 1.2 例子

#### 1.2.1 同步程序

通过加锁实现线程A和线程B的同步

![2](p/2.png)

#### 1.2.2 未同步程序

虽然未同步，操作的执行整体上无序，但是两个线程都能看到执行顺序（因为顺序一致性模型保证每个线程的操作对其他线程立即可见）

![2](p/3.png)

## 2. JMM

### 2.1 什么是JMM

* JMM是一种规范，定义了一组规则，目的是为了保护并发编程的特性不被破坏，**解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题**
* **JMM的方针是：对于正确同步的程序，那么在不改变程序执行结果的前提下，尽可能地为编译器和处理器的优化打开方便之门**
* JVM依据JMM实现

### 2.2 JMM描述的规则

* 定义线程和主内存之间的抽象关系
* 定义了8种内存交互操作及其规则
* 规定线程之间如何通信
* 限制指令重排序

#### 2.2.1 线程和主内存之间的抽象关系

![JMM](p/JMM.png)

* 线程之间的共享变量存储在主内存中
* 每个线程都有一个**私有的本地内存(抽象概念)**，本地内存存储了该线程需要使用的共享变量的副本

#### 2.2.2 八种内存交互操作

![JMM](p/7.jpg)

- **lock(锁定)**，作用于**主内存**中的变量，把变量标识为线程独占的状态。
- **read(读取)**，作用于**主内存**的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。
- **load(加载)**，作用于**工作内存**的变量，把read操作主存的变量放入到工作内存的变量副本中。
- **use(使用)**，作用于**工作内存**的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
- **assign(赋值)**，作用于**工作内存**的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。
- **store(存储)**，作用于**工作内存**的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。
- **write(写入)**：作用于**主内存**中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
- **unlock(解锁)**：作用于**主内存**的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。

**规则**

- 不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。
- 不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。
- 不允许线程将没有assign的数据从工作内存同步到主内存。
- 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。
- 一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。
- 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。
- 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。
- 一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。

#### 2.3.3 线程之间如何通信

**JMM要求线程之间的通信必须经过主内存**

如果线程A与线程B之间想要通信，那么需要经过2个步骤

1. 线程A在本地内存修改后，刷新到主内存中
2. 主内存同步到线程B的本地内存后，由线程B读取

#### 2.3.4 限制指令重排序

* 对于编译器重排序，JMM的编译器重排序规则会禁止特定类型的编译器重排序
* 对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成某些指令时，插入**内存屏障指令**，通过内存屏障指令来禁止特定类型的处理器重排序

**内存屏障的类型**

| 屏障类型                | 指令示例                       | 说明                                                       |
| ------------------- | -------------------------- | -------------------------------------------------------- |
| LoadLoad Barriers   | Load1; LoadLoad; Load2     | 禁止指令重排序，Load1一定先于Load2                                   |
| StoreStore Barriers | Store1; StoreStore; Store2 | 禁止指令重排序，store1一定先于store2;   store1写的数据会立刻同步到主内存中，对所有线程可见 |
| LoadStore Barriers  | Load1; LoadStore; Store2   | 禁止指令重排序，Load1一定先于Store2                                  |
| StoreLoad Barriers  | Store1; StoreLoad; Load2   | 禁止指令重排序，Store一定先于Load2 ； store1写的数据会立刻同步到主内存中，对所有线程可见    |

## 3. happens-before规则

#### 3.1 为什么要有happens-before

* JMM定义的规则难以理解和编程，happens-before便于程序员理解和编程，每条happens-before规则对应着多条JMM定义的规则
* 程序员希望基于一个强内存模型进行程序编写，但JMM为了尽可能发挥处理器性能，实现的是一个弱内存模型，所以JMM提供happens-before规则，happens-before规则是JMM呈现给程序员的视图，让程序员看到一个强内存模型视图，但是JMM底层实现是弱内存模型

![happens-before](p/happens-before.png)

#### 3.2 happens-before的定义

如果一个操作happens-before另一个操作，那么第一个操作先于第二个操作执行，并且第一个操作的执行结果将对第二个操作可见（这个是happens-before给程序员提供的视图，但是JMM底层可能会重排序，两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照 happens-before指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么JMM允许这种重排序）

#### 3.3 happens-before内容

1. 程序顺序规则：一个线程中的每个操作，happens-before于该线程中后续任意操作。 

2. 锁定规则：加锁happens-before解锁

3. volatile变量规则：对一个volatile变量的写操作，happens-before于后续任意对这个volatile变量的读操作。 

4. 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。 

5. 线程启动规则：如果线程A调用线程B的start()方法来启动线程B，则start()操作Happens-Before于线程B中的任意操作

6. 线程终止规则：线程A等待线程B完成（在线程A中调用线程B的join()方法实现），当线程B完成后（线程A调用线程B的join()方法返回），则线程A能够访问到线程B对共享变量的操作

7. 线程中断规则：对线程interrupt()方法的调用Happens-Before于被中断线程的代码检测到中断事件的发生

8. 对象终止规则：一个对象的初始化完成Happens-Before于它的finalize()方法的开始

## 4. 顺序一致性模型与JMM的区别

* 顺序一致性模型是强内存模型，JMM是弱内存模型

* 顺序一致性模型保证对内存的读写操作都是原子的，JMM不保证对64位double或long数据的读写是原子的

* 顺序一致性模型保证单线程程序按照代码顺序执行，JMM不保证（即使程序正确同步，临界区中的代码可以重排序）
  
  ![4](p/4.png)

* 不管程序是否同步，顺序一致性模型中，所有线程都看到的都是同一个操作执行熟悉怒（JMM不保证，因为JMM中线程在本地内存修改数据，在刷新到主内存之前，其他线程不可见）