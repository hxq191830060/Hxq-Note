# 1. 缓存穿透

## 1.1 什么是缓存穿透

用户查询一个数据，Redis中没有(缓存没命中)，于是向持久层数据库查询，持久层数据库也没有，并且不将空结果写入缓存

当这样的查询很多时，缓存都没有命中，于是都去请求持久层数据库，失去了缓存保护后端持久层的意义，这就是缓存穿透

## 1.2 解决方案

### 1.2.1 布隆过滤器拦截

布隆过滤器是一种数据结构，对查询使用的所有参数以hash形式存储，在控制层进行校验，不符合则丢弃，避免了对底层存储系统的查询压力

![布隆过滤器](D:\桌面\Notes\Notes\数据库\Redis\p\布隆过滤器.png)

#### 布隆过滤器问题

* 代码维护复杂



### 1.2.2. 缓存空对象

当存储层未命中后，即使返回空对象也存储起来，同时设置一个过期时间

![缓存空对象](D:\桌面\Notes\Notes\数据库\Redis\p\缓存空对象.png)

#### **缓存空对象的问题**

1. 如果空值能被缓存起来，这就意味着缓存需要更多的空间存储更多的键

2. 即使对空值设置了过期时间，还是会存在缓存层和存储层的数据有一段时间的不一致

   > 例如一个空值设置了过期时间5min，这期间如果持久层中添加了这个数据，那么这段时间缓存层和持久层的数据就不一致

# 2. 缓存击穿

## 2.1 什么是缓存击穿

缓存击穿——指的是一个key非常热点，并发量很大

这个key过期的瞬间，大量的请求并发访问持久层数据库，导致数据库瞬间压力过大，可能让应用崩溃

## 2.2 解决方案

### 2.2.1. 设置热点数据永不过期

* 从缓存层面——不设置过期时间
* 从功能层面——为每个key设置一个逻辑过期时间，当发现超过逻辑过期时间后，使用专门的线程去持久层获取最新的数据来更新key

#### 问题

* 会出现数据不一致的情况，并且代码复杂

### 2.2.2. 加互斥锁

分布式锁，使用分布式锁，保证对于每个key，某一时间只有一个线程去查询持久层数据

#### 问题

* 可能存在死锁和线程池阻塞的风险，但是一致性好



# 3. 缓存雪崩

## 3.1 什么是缓存雪崩

某一个时间段，缓存集中过期失效

例如：马上到双十二零点，这波商品数据集中放入缓存，假设缓存1小时，到了凌晨1点时，这批商品的缓存都过期了，对这批商品的访问，都直接落在了持久层数据库上。

key集中过期并不是非常致命

比较致命的缓存雪崩，是缓存服务器的某个节点宕机或者断网，不能提供服务，所有请求到达持久层，持久层的调用量暴增，造成持久层也会级联宕机

## 3.2 解决方案

### 3.2.1. Redis高可用

Redis Sentinel和Redis Cluster

### 3.2.2. 限流降级

### 3.2.3. 数据预热

在正式部署之前，先把可能的数据预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中