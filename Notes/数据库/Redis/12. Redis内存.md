# 1. 内存消耗

## 1.1 Redis进程内的内存消耗

Redis进程内的内存消耗划分为

* 自身内存(Redis空进程占用内存)
* 对象内存
* 缓冲内存
* 内存碎片

### 1.1.1 自身内存

Redis空进程占用内存（非常少，3MB左右）

### 1.1.2 对象内存

存储所有的数据——所有的key-value

### 1.1.3 缓冲内存

* 客户端缓冲
  * 客户端输入缓冲区
  * 客户端输出缓冲区
* 复制积压缓冲区
* AOF缓冲区
  * aof_buf
  * aof_rewrite_buf

### 1.1.4 内存碎片

Redis默认的内存分配器为 jemalloc

jemalloc将内存空间划分为

* 小——[8b]，[16b，32b，48b，...... ，128b]，[192b，256b，...... ，512b]，[768b，1024b，...... ，3840b]
* 大——[4KB，8KB，12KB，...... ，4072KB]
* 巨大——[4MB，8MB，12MB，......]

比如保存5KB的对象，jemalloc可能会采用8KB的内存块来鵆，剩下的3KB空间就成为了内存碎片

## 1.2 子进程内存消耗

子进程内存消耗——执行AOF重写，RDB持久化时Redis通过fork操作创建子进程的内存消耗

* fork操作产生的子进程内存占用量对外变现为与父进程相同，理论上需要一倍的物理内存
* Linux有 **写时复制技术(copy-on-write)**，父进程与子进程共享相同的物理内存页
  * 父进程处理写请求时为需要修改的页创建副本，然后在副本上完成写请求
  * 子进程依然读取fork时整个父进程的内存快照

#### THP机制对子进程内存消耗的影响

Linux Kernel在2.6.38内核中增加了 **Transparent Huge Pages(THP)机制**

* 降低了fork的耗时
* copy-on-write期间，复制内存页的单位由4KB变为2MB——如果父进程有大量写命令，会加重内存拷贝量

**建议关闭THP——防止copy-on-write期间内存过度消耗**



# 2. 内存管理

## 2.1 设置内存上限

Redis使用 **maxmemory参数限制最大可用内存**

* 超过内存上限maxmemory时使用LRU等内存回收策略释放空间
* 防止所用内存超过服务器物理内存



## 2.2 内存回收策略

Redis内存回收机制体现在两方面

* **删除过期的键**
* **内存使用达到maxmemory时触发内存溢出控制策略**



### 2.2.1 删除过期的键

Redis有两种**过期键删除策略**—— **惰性删除** 和 **定时删除**



#### 2.2.1.1 惰性删除

主节点每次处理读命令时，都会检查key是否超时，如果超时——执行del命令删除key，然后将del命令异步发送给从节点

**有内存泄漏的问题——过期key一直没有被访问，那么其内存就无法被及时释放**



#### 2.2.1.2 定时删除

Redis内部维护一个定时任务(每秒10次)

1. 默认采用慢模式运行——定时任务在每个数据库空间随机检查20个key，当发现过期的key时删除
2. 如果检查到超过25%的key过期，那么循环执行回收逻辑直到不足25%或者超时（慢模式下超时时间为25毫秒）
3. 如果第2步超时了——那么采用快模式（快模式下超时时间为1毫秒，且2s内只运行1次）



## 2.3 内存溢出控制策略

Redis所使用的内存达到maxmemory上限会触发响应的内存溢出控制策略——受**参数maxmemory-policy**控制

* **noeviction**：默认策略，不会删除任何数据，拒绝所有写请求
* **volatile-lru**：根据LRU算法删除设置了超时属性的key，直到腾出足够空间位置，如果没有可删除的key，回退到 **noeviction策略**
* **allkeys-lru**：根据LRU算法删除key，不管key有没有设置超时属性，直到腾出足够位置为止
* **allkeys-random**：随机删除所有key，直到腾出足够空间位置
* **volatile-random**：随机删除过期键，直到腾出足够空间位置
* **volatile-ttl**：根据key的ttl属性，删除最近将要过期的数据，如果没有，回退到 **noeviction策略**



**如果Redis一直工作在内存溢出的状态下并且设置了非noeviction策略——会频繁触发回收内存的操作，影响Redis性能**



# 3. 内存优化

## 3.1 redisObject对象

Redis存储的数据都用**redisObject**来封装

```c
typedef struct redisObject{
    unsigned int type;      //4B，对象类型
    unsigned int encoding;  //4B，内部编码类型
    REDIS_LRU_BITS lru;     //记录对象最后一次被访问的时间
    int refcount;           //引用计数器，记录当前对象被引用的次数
    void * ptr              //与对象的数据内容相关——如果是整数，直接存储数据，否则为指向数据的指针
}
```

## 3.2 共享对象池

Redis内部维护0—9999的证书对象池

如果创建0-9999的证书，直接使用整数对象池中的对象——节约内存

**如果设置了maxmemory并且开启了 volatile-lru策略 or allkeys-lru策略，那么Redis将禁用共享对象池**



## 3.3 字符串优化

### 3.3.1 字符串结构

Redis内部实现了 简单动态字符串(simple dynamic string，SDS)

```c
typedef struct SBS{
    int len;   //已用长度
    int free;  //未用长度
    char buf[];//字符数据
}
```

### 3.3.2 空间预分配机制

Redis的字符串采用了**空间预分配机制**——防止修改操作需要不断重分配内存和字节数据拷贝

* 第一次创建时，len属性=实际大小，free为0，不做预分配

* 修改后，如果已有free空间不够且数据<1MB，每次预分配一倍容量

  >原有len=60b，free=0，再追加60b，预分配120b——len=120b，free=120b

* 修改后，如果已有free空间不够且数据>1MB，每次预分配1MB容量



## 3.4 编码优化

### 3.4.1 编码类型转换

Redis在写入数据时自动进行编码类型转换

* 转换不可逆
* 转换规则：只能由小内存编码向大内存编码转换

### 3.4.2 ziplist编码

ziplist编码的主要目的是节约内存——因此所有的数据都采用线性连续的内存结构

#### 3.4.2.1 ziplist结构

![ziplist结构.drawio](p/ziplist结构.drawio.png)

#### 3.4.2.2 ziplist特点

* 内部表现为数据紧凑排列的一块连续内存数组——节约内存
* 可以模拟双向链表结构，以O(1)实现入队和出队
* 读写操作涉及复杂的指针移动，最坏时间复杂度为O(n2)

**ziplist适合在数据类小时使用——省内存；数据量大时，由于ziplist读写效率低，不要使用ziplist**



