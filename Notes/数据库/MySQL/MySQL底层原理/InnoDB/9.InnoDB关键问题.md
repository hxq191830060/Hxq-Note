## 1. InnoDB如何避免幻读

* InnoDB在 **REPEATABLE READ**下，使用 Next-Key Lock加锁算法，避免了幻读

  InnoDB在 **READ COMMITTED**下，除了外键约束和唯一性检查需要Gap Lock，其余情况仅使用 Record Lock进行锁定，无法避免幻读

* InnoDB在RR下，MVCC可以在一定程度上避免幻读

  * 如果RR下，进行多次快照读，那么这多次快照读都是基于事务同一个readview，可以避免幻读
  * 如果RR下，多次快照读之间，掺杂有当前读，由于当前读会重新生成readview，导致后续的快照读与前面的快照度基于不同的readview，无法避免幻读





## 2. MVCC机制如何实现

仅仅 **REPEATABLE READ**和 **READ COMMITTED**支持MVCC

MVCC根据undo实现的，用户读取一行记录时，若该记录已经被其他事务占用，那么事务通过undo来读取该记录之前的版本信息，以此实现非锁定读取

**undo对MVCC的支持**

* 事务提交后，不会马上删除undo log和undo log所在的页,而是将将undo log放入一个**链表**中，是否可以最终删除undo log和undo log所在页由**purge线程**判断**（提供MVCC机制，可能有其他事务需要通过undo log获取行记录之前的版本）**
* delete和update操作——不会删除原来的记录，而是将其标记为已删除，最终的删除操作由**purge**完成**（提供MVCC机制，可能有其他事务需要获取旧的记录信息）**