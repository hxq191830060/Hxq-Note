

## 1. 锁的类型

MySQL Server层——支持表锁

InnoDB——支持行锁，意向锁

### 1.0 锁兼容

一个事务想要访问某个资源，需要先获得该资源对象的锁

如果事务想要获取资源的A锁，但是该资源的B锁已经被其他事务获取，A锁与B锁不兼容——当前事务阻塞等待B锁的释放

如果事务想要获取资源的A锁，但是该资源的B锁已经被其他事务获取，A锁与B锁兼容——当前事务成功获得A锁访问资源



### 1.1 全局锁

对整个数据库实例加锁，MySQL提供了一个加全局读锁的方法—— **Flush Table with Read Lock**

该命令让整个数据库实例处于只读状态，其他事务的写操作语句都会被阻塞



全局锁的典型使用场景—— **做全库逻辑备份**，也就是把整库每个表都select出来存成文本

但是让整库都只读，听上去就很危险：

* 如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆
* 如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。

### 1.2 表级锁

#### 1.2.1 表锁

- **共享锁(S Lock)**：允许事务对表进行读操作
- **排他锁(X Lock)**：允许事务对表进行写操作

**表锁的使用——lock tables ... read/write**

#### 1.2.2 元数据锁

MDL(metadata Lock)，MDL不需要显示使用，访问一个表的时候自动加上

* 对一个表做增删改查时，加MDL读锁
* 更改表结构时，加MDL写锁

* 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查
* 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时要更改一个表的表结构，其中一个要等另一个执行完才能开始执行。

### 1.3 行级锁

InnoDB支持两种行锁

- **共享锁(S Lock)**：允许事务读取一行数据
- **排他锁(X Lock)**：允许事务删除or更新一行数据



**两阶段锁协议**——行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放

### 1.4 意向锁

因为使用InnoDB时，可能同时存在表锁和行锁，为了支持不同粒度上的加锁，引入了意向锁

意向锁也是一种表锁

- **意向共享锁(IS Lock)**：事务想获得一张表中某几行的共享锁
- **意向排他锁(IX Lock)**：事务想获得一张表中某几行的排他锁



### 1.5 锁的使用与兼容问题

![21](../picture/21.png)

我们把上锁的对象看作一棵树

那么我们如果想给粒度最小的对象上锁，就需要先给粒度较大的对象上锁



**给记录加上行级S(X) Lock**

1. 给数据库加IS(IX) Lock
2. 给表加上IS(IX) Lock
3. 给页加上IS(IX) Lock
4. 给记录加上S(X) Lock

（任何一步出现锁不兼容的情况，就需要等待资源上不兼容的锁释放）



**给表加上S(X) Lock**——直接给表加上S(X) Lock

![22](../picture/22.png)



## 2. 一致性非锁定读(MVCC)

**一致性非锁定读**——通过**多版本并发控制(MVCC)**的方式来读取当前执行时间数据库中行的数据

一个事务想要读取行C，但是行C的X锁被另一个事务获取，那么该事务不需要等待X锁的释放，可以通过**undo段**来获取该行之前版本的数据

**READ COMMITTED**和 **REPEATABLE READ**——支持MVCC，默认通过MVCC进行**一致性非锁定读**来读取数据



### 2.1 快照读与当前读

* **快照读**

  > 普通的select语句

  * **快照读**通过**MVCC**获取数据（RR或RC隔离等级下）

* **当前读**

  读取记录当前的值

  > insert，update，delete，select...for update，select...lock in share mode都是当前读
  >
  > **更新数据——一定是先进行当前读，然后再进行更新**

  * **当前读**通过**行锁，间隙锁**来获取数据



### 2.2 MVCC实现

MVCC依赖**undo log**和**read view**实现

#### 2.2.1 undo log和trx_id

MVCC的实现依赖于**undo log**

* InnoDB中读写事务会分配一个唯一的事务ID（由全局ID生成器生成，全局递增），只读事务的事务ID为0

* 事务的每个写操作，都会在undo log中记录一条逻辑相反的日志

* 每行记录可以有多个版本，每个数据版本都有一个**row trx_id**（导致该版本产生的事务的事务ID）

最新版本的记录和其row trx_id是可以直接获取到的，旧版本的记录和其row trx_id需要通过undo log计算得到

>下图显示了一条记录的4个版本
>
>V4是最新版本的记录，是可以直接获取的
>
>U1,U2,U3是undo log
>
>V3可以通过最新版本的V4和undo log U3计算得到
>
>![1](../picture/1.webp)

#### 2.2.2 readview进行版本判断

>**readview**是一个**数据结构**，包含四个字段
>
>* 当前全部的活跃事务的ID
>* 当前事务的事务ID
>* 全部活跃事务中事务ID的最小值
>* 全部活跃事务中事务ID的最大值

MVCC是通过**readview**来实现记录版本的判断

* MySQL中维护有全局的活跃事务ID——当前全部的已经开始但还未提交的读写事务的事务ID
* 事务创建readview时，会将这些事务ID拷贝到**read_view_t->descriptors**，并找出出这些事务ID中的**最大值low_trx_id**和**最小值up_limit_id**
* 每条记录都有其row trx_id，事务读取一条记录时
  * 如果记录的trx_id满足 trx_id < up_limit_id——该记录最后的修改在readview创建前，可以获取
  * 如果记录的trx_id满足 up_limit_id < trx_id < low_trx_id——该记录最后修改在readview之后，不可以获取，通过undo log计算出该记录可见的老版本
  * 如果记录的trx_id满足 trx_id >= low_trx_id
    * 如果该记录的trx_id存在于 **read_view_t->descriptors**——则表示这条记录的最后修改是在readview创建之时，被另外一个活跃事务所修改，所以这条记录也不可以被看见，通过undo log计算出该记录可见的老版本
    * 如果该记录的trx_id不存在于 **read_view_t->descriptors**——表示这条记录的最后修改在readview创建之前，所以可以看到



### 2.3 REPEATABLE，READ COMMITED与MVCC

* **READ COMMITTED下**
  * 实现上——每条SQL都会重新构建一个readview
  * 宏观表现——任何时候，如果行未被锁定，那么直接读取行当前的数据，如果行被锁定了，那么读取最近的版本的数据

- **REPEATABLE READ下**

  * 实现上——事务执行第一条SQL时，生成一个readview，后续的操作都是基于该readview

  * **一旦进行当前读后，会重新生成一个readview**

  * **RR下，MVCC可以在一定程度上避免幻读，但不绝对**

    * 如果RR下，进行多次快照读，那么这多次快照度都是基于**同一个的readview**，可以避免幻读
    * 如果RR下，多次快照读之间，掺杂有当前读，由于**当前读会重新生成readview**，导致后续的快照读与前面的快照度基于不同的readview，无法避免幻读

    

  



## 3. 一致性锁定读

用户显示地对读取操作进行加锁——保证数据逻辑的一致性——这就是一致性锁定读

- select ... for update：主动给读取的记录加上X锁
- select ... lock in share mode：主动给读取的记录加上S锁



## 4. 锁的算法

InnoDB有三种锁算法

- **Record Lock**：只会对聚集索引中的行记录上锁
- **Gap Lock**：在辅助索引中锁住一个范围，不会对聚集索引中的行记录上锁
- **Next-Key Lock**：等于Record Lock+Gap Lock，锁定一个范围的同时，对行记录本身也上锁

> 下图中，红色表示Record Lock(锁住了a=4的记录)，蓝色表示Gap Lock(锁住了b<=1的记录)
>
> ![锁算法.drawio](../picture/锁算法.drawio.png)
>
> 紫色代表Next-Key Lock
>
> ![锁算法.drawio1](../picture/锁算法.drawio1.png)



### 4.1 REPEATABLE READ隔离等级下

- 在**REPEATABLE READ**下

  * 如果进行**当前读**——使用**Next-Key Lock锁定算法**——**避免了幻读**
  * 如果进行 **快照读**——使用MVCC获取数据

  假设通过辅助索引b进行查询，索引b的可能值有10,11,13,20，那么可以锁定的区间有(-∞,10),[10,11),[11,13),[13,20),[20,+∞)

  InnoDB除了会对目标值所在区间加上锁之外，还会对下一个区间加上gap lock

  > 辅助索引b值为1,1,3,6,8，查询b=3的记录
  >
  > 使用Next-Key Lock，锁定的范围为(1,3)，InnoDB还会对辅助索引下一个区间加上gap lock(即给(3,6)加上gap lock)

- 如果是查询使用的索引具有唯一属性——将Next-Key Lock降级为 Record Lock

- **使用了Gap Lock**——阻止多个事务将记录插入同一个范围，避免了幻读



### 4.2 READ COMMITTED隔离等级下

- 在 **READ COMMITED**下，除了外键约束和唯一性检查需要Gap Lock，其余情况仅使用 Record Lock进行锁定，无法防止幻读

  * 如果进行 **当前读**——使用Record Lock进行锁定

  * 如果进行 **快照读**——使用MVCC获取数据



## 5. 锁问题

### 5.1 脏读

读取到另一个事务中未提交的数据

### 5.2 不可重复读

是指一个事务读取数据库中的数据后，另一个事务则修改或删除数据，当第一个事务再次执行同一查询时，就会发现数据已经发生了改变，这就是不可重复读

### 5.3 幻读

一个事务内执行2次同样的SQL，第二次的SQL相比于第一次SQL改变了数据量

### 5.4 丢失更新

一个事务的更新操作被另一个事务的更新操作覆盖，从而导致数据的不一致

## 6. 死锁

死锁指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象

**解决死锁的方法**

### 6.1 超时(InnoDB不使用)

两个事务相互等待时，当事务的等待时间超过设置的某一阈值时会进行回滚

### 6.2 wait-for graph(InnoDB使用)

InnoDB使用wait-for graph的方式来进行死锁检测

wait-for graph要求数据库保存两种信息—— **锁的信息链表**，**事务等待链表**

通过上述链表可以构造一张图，若在这个图中存在回路，就代表存在死锁

**wait-for graph是一种主动的死锁监测机制，每个事务请求锁并发生等待时会判断是否存在回路，若存在则有死锁——InnoDB会选择回滚undo量最小的事务**