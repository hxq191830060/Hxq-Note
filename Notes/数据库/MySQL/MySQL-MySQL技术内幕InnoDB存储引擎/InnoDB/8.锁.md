

## 1. 锁的类型

MySQL Server层——支持表锁

InnoDB——支持行锁，意向锁

### 1.1 锁兼容

一个事务想要访问某个资源，需要先获得该资源对象的锁

如果事务想要获取资源的A锁，但是该资源的B锁已经被其他事务获取，A锁与B锁不兼容——当前事务阻塞等待B锁的释放

如果事务想要获取资源的A锁，但是该资源的B锁已经被其他事务获取，A锁与B锁兼容——当前事务成功获得A锁访问资源



### 1.2 表锁

MySQL Server支持表锁，分为

- **共享锁(S Lock)**：允许事务对表进行读操作
- **排他锁(X Lock)**：允许事务对表进行写操作

### 1.3 行锁

InnoDB支持两种行锁

- **共享锁(S Lock)**：允许事务读取一行数据
- **排他锁(X Lock)**：允许事务删除or更新一行数据

### 1.4 意向锁

因为使用InnoDB时，可能同时存在表锁和行锁，为了支持不同粒度上的加锁，引入了意向锁

意向锁也是一种表锁

- **意向共享锁(IS Lock)**：事务想获得一张表中某几行的共享锁
- **意向排他锁(IX Lock)**：事务想获得一张表中某几行的排他锁



### 1.5 锁的使用与兼容问题

![21](../picture/21.png)

我们把上锁的对象看作一棵树

那么我们如果想给粒度最小的对象上锁，就需要先给粒度较大的对象上锁



**给记录加上S(X) Lock**

1. 给数据库加IS(IX) Lock
2. 给表加上IS(IX) Lock
3. 给页加上IS(IX) Lock
4. 给记录加上S(X) Lock

（任何一步出现锁不兼容的情况，就需要等待资源上不兼容的锁释放）



**给表加上S(X) Lock**——直接给表加上S(X) Lock

![22](../picture/22.png)



## 2. 一致性非锁定读(MVCC)

**一致性非锁定读**——通过**多版本并发控制(MVCC)**的方式来读取当前执行时间数据库中行的数据

一个事务想要读取行C，但是行C的X锁被另一个事务获取，那么该事务不需要等待X锁的释放，可以通过**undo段**来获取该行之前版本的数据

事务隔离等级为 **READ COMMITTED**和 **REPEATABLE READ**下——支持MVCC，**一致性非锁定读**是默认的读取方式



每个行可能有多个版本

- **READ COMMITED下**，任何时候，如果行未被锁定，那么直接读取行的数据，如果行被锁定了，那么读取最新的版本的数据
- **REPEATABLE READ下**，读取事务开始时的版本的数据

## 3. 一致性锁定读

用户显示地对读取操作进行加锁——保证数据逻辑的一致性——这就是一致性锁定读

- select ... for update：主动给读取的记录加上X锁
- select ... lock in share mode：主动给读取的记录加上S锁



## 4. 锁的算法

InnoDB有三种锁算法

- **Record Lock**：只会对聚集索引中的行记录上锁
- **Gap Lock**：在辅助索引中锁住一个范围，不会对聚集索引中的行记录上锁
- **Next-Key Lock**：等于Record Lock+Gap Lock，锁定一个范围的同时，对行记录本身也上锁

> 下图中，红色表示Record Lock(锁住了a=4的记录)，蓝色表示Gap Lock(锁住了b<=1的记录)
>
> ![锁算法.drawio](../picture/锁算法.drawio.png)
>
> 紫色代表Next-Key Lock
>
> ![锁算法.drawio1](../picture/锁算法.drawio1.png)



### 4.1 REPEATABLE READ隔离等级下

- 在**REPEATABLE READ**下，**InnoDB对行的查询都使用Next-Key Lock锁定算法**

  假设通过辅助索引b进行查询，索引b的可能值有10,11,13,20，那么可以锁定的区间有(-∞,10),[10,11),[11,13),[13,20),[20,+∞)

  InnoDB除了会对目标值所在区间加上锁之外，还会对下一个区间加上gap lock

  > 辅助索引b值为1,1,3,6,8，查询b=3的记录
  >
  > 使用Next-Key Lock，锁定的范围为(1,3)，InnoDB还会对辅助索引下一个区间加上gap lock(即给(3,6)加上gap lock)

- 如果是查询使用的索引具有唯一属性——将Next-Key Lock降级为 Record Lock

- **使用了Gap Lock**——阻止多个事务将记录插入同一个范围，避免了幻读



### 4.2 READ COMMITTED隔离等级下

- 在 **READ COMMITED**下，除了外键约束和唯一性检查需要Gap Lock，其余情况仅使用 Record Lock进行锁定，无法防止幻读



## 5. 锁问题

### 5.1 脏读

读取到另一个事务中未提交的数据

### 5.2 不可重复读

是指一个事务读取数据库中的数据后，另一个事务则修改或删除数据，当第一个事务再次执行同一查询时，就会发现数据已经发生了改变，这就是不可重复读

### 5.3 幻读

一个事务内执行2次同样的SQL，第二次的SQL可能返回第一次SQL不存在的行

### 5.4 丢失更新

一个事务的更新操作被另一个事务的更新操作覆盖，从而导致数据的不一致

## 6. 死锁

死锁指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象

**解决死锁的方法**

### 6.1 超时(InnoDB不使用)

两个事务相互等待时，当事务的等待时间超过设置的某一阈值时会进行回滚

### 6.2 wait-for graph(InnoDB使用)

InnoDB使用wait-for graph的方式来进行死锁检测

wait-for graph要求数据库保存两种信息—— **锁的信息链表**，**事务等待链表**

通过上述链表可以构造一张图，若在这个图中存在回路，就代表存在死锁

**wait-for graph是一种主动的死锁监测机制，每个事务请求锁并发生等待时会判断是否存在回路，若存在则有死锁——InnoDB会选择回滚undo量最小的事务**