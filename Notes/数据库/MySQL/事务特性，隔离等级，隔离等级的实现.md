1. **事务的特性ACID**
   * 原子性(Atomicity)
   * 一致性(Consistency)
   * 隔离性(Isolation)
   * 持久性(Durability)



------

**接下来我们要讲的是事务的隔离性**

1. **事务隔离性导致的问题** 

   * **脏读** 

     一个事务读取到了其他事物未提交的数据

   * **不可重复读** 

     一个事务的操作需要对某些记录进行两次读取，两次读取到的记录不同(两次读取期间，有其他事务修改update了记录)

   * **幻读**

     一个事务的操作需要对表进行2次范围查询，两次查询的结果不同(两次访问之间，有其他事务insert记录)

2. **事务四大隔离等级**

   * **串行化**

     避免了所有问题，但是效率最低

   * **可重复读(Mysql默认等级)**

     避免了脏读和不可重复读，有的数据库无法避免幻读，但是MySQL通过MVVC避免了幻读

   * **读已提交**

     避免了脏读

   * **读未提交**

     什么都避免不了

3. **四个隔离等级的实现**

   * **串行化**

     读时加共享锁，其他事务也可以读，不可以写

     写时加排它锁，其他事务不能读写

   * **可重复读**

     MVCC

     * **MVCC**

       数据库中的一行记录可能有多个版本，每个版本的记录除了有数据本身外，还有一个表示版本的字段，这个字段就是使该版本记录产生的事务的id

       ![image-20210607094826546](C:\Users\90747\AppData\Roaming\Typora\typora-user-images\image-20210607094826546.png)

       可重复读，在事务开始的时候生成一个当前事务全局性快照，只能对快照中的记录进行操作

       * 快照包含的数据规则
         * ①当前事务内的更新操作，可以读到
         * ②其他事务未提交的，不能读到
         * ③其他事务已提交的，但在快照创建后提交的，不能读到
         * ④其他事务已提交的，且在快照之创建前提交的，可以读到

   * **读已提交**

     MVCC(每条SQL语句执行后都重新生成一张快照)

   * **读未提交**

     不加锁