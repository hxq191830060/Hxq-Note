到了这里我们已经实现了四大安全通信，但还有一个问题——**公钥的信任问题**   
谁都可以发布公钥，如何判断这个公钥就是用户的或者网站的公钥？   
为了解决这个问题——我们引入**CA(Certificate Authority证书认证机构)**，由CA对公钥签名，用CA的信誉保证公钥是可信的  

------

### **TLS协议的子协议**

* 记录协议

  规定了TLS收发数据的基本单位——记录(record)

  多个record可以在一个TCP包内一次性发出，并且不需要返回ACK

* 警报协议

  向对方发出警报信息

* 握手协议

* 变更密码规范协议

------



### **TLS协议的工作原理**

* **前提**

  服务器已经向CA申请了证书

  ![1](p\1.png)

* **工作分为两阶段**
  
  * 握手——建立连接
    * TCP握手
    * TLS握手——根据使用的密码套件不同，分为许多种，这里仅仅列出两种，不同的密码套件，过程有一些轻微的差别
      * ECDHE握手(主流)
      * RSA握手(传统)
  * 通信  
    
  
* **TLS握手的简要描述**   
  下图每个框代表一个record，多个record可以在一个TCP包中一起发送
  
  所有最少还需要4个TCP包就可以完成TLS握手
  ![1](p\img_2.png)

------

### TLS握手详解

#### ECDHE握手详解——使用密钥交换算法ECDHE

* TCP握手，建立TCP连接——TLS收发数据的基本单位是record，多个record可以由一个TCP包发送(每收到一个TCP包就返回一个ACK，下面不在赘述)

* TLS-ECDHE握手(以record为单位)

  1. Client向Server发送"Client Hello" record(第一个TCP)

     * Client的TLS版本号
     * Client支持的密码套件列表
     * **随机数Client Random**

  2. Server向Client发送"Server Hello" record(第二个TCP)

     * 确认TLS版本号
     * **选择使用密码套件(ECDHE)**
     * **随机数Server Random**

  3. Server向Client发送"Certificate" record(第二个TCP)

     * 服务器的证书

  4. Server向Client发送"Server Key Exchange" record(第二个TCP)

     * **密钥交换算法参数**——**Server Params**
     * Server的私钥签名

  5. Server向Client发送"Server Hello Done" record(第二个TCP)

     * 结束Server Hello
     * 到这了，Server与Client明文共享了三个信息——**Client Random**，**Server Random**，**Server Params**

  6. **客户端检验证书，获取Server的公钥**

     **然后用Server的公钥验证Server的私钥签名，确认了Server的身份**

  7. Client生成一个**密钥交换算法参数**Client Params

     Client向Server发送"Client Key Exchange" record(第三个TCP)

     * 秘钥交换算法的参数——**Client Params**

  8. **Client与Server手中都有Server Params和Client Params**

     Client和Server使用**Server Params**和**Client Params**执行ECDHE算法，计算出**Pre-Master（ECDHE算法保证，即使黑客截取了这些参数，也计算不出Pre-Master)**

     Client与Server手中有——**Client Random**，**Server Random**，**Pre-Master**

     Client和Server使用**Client Random**，**Server Random**，**Pre-Master**计算出加密会话的主秘钥——**Master Secret**，并且由主密钥派生出用于通信的**会话秘钥**

     ------

     **（Change Cipher Spec之前都是明文，Change Cipher Spec之后都是密文)**

  9. Client向Server发送一个**Change Cipher Spec** record(第三个TCP)

     * 告诉服务器后面的通信都是用**对称加密算法**，**会话秘钥**来加密通信

  10. Client向Server发送一个**Encrypted Handshake Message** record(第三个TCP)

      * 所有握手数据的摘要

      ------

      **（ECDHE从这里就可以发送HTTP报文了，不用等Server发完Finished）**

  11. 服务器也发送**Change Cipher Spec**和**Encrypted Handshake Message**   (第四个TCP)

  12. 双方验证加密解密都OK，TLS握手结束 

* 通信

  后续通信的内容，都通过**对称加密算法**和**会话秘钥**来加密和解密

![1](p\img_3.png)



### RSA握手详解

* TCP握手，建立TCP连接——TLS收发数据的基本单位是record，多个record可以由一个TCP包发送(每收到一个TCP包就返回一个ACK，下面不在赘述)

* TLS-RSA握手(以record为单位)

  1. Client向Server发送"Client Hello" record(第一个TCP)

     * Client的TLS版本号
     * Client支持的密码套件列表
     * **随机数Client Random**

  2. Server向Client发送"Server Hello" record(第二个TCP)

     * 确认TLS版本号
     * **选择使用密码套件(RSA)**
     * **随机数Server Random**

  3. Server向Client发送"Certificate" record(第二个TCP)

     * 服务器的证书

  4. Server向Client发送"Server Hello Done" record(第二个TCP)

     * 结束Server Hello

  5. **客户端检验证书，获取Server的公钥**

  6. Client随机生成**pre-master**

     Client向Server发送"Client Key Exchange" record（第三个TCP）

     * 用**Server的公钥**加密**pre-master**得到的密文

  7. Server用私钥对密文解密，得到**pre-master**

  8. Client和Server使用**Client Random，Server Random，pre-master**计算得到**主密钥master secret**，并由主密钥得到派生的**会话秘钥**

     ------

     **（除了pre-master必须用公钥加密传输，Change Cipher Spec之前都是明文，Change Cipher Spec之后都是密文)**

  9. Client向Server发送一个**Change Cipher Spec** record（第三个TCP）

     * 告诉服务器后面的通信都是用**对称加密算法**，**会话秘钥**来加密通信

  10. Client向Server发送一个**Encrypted Handshake Message** record（第三个TCP）

      * 所有握手数据的摘要

  11. 服务器也发送**Change Cipher Spec**和**Encrypted Handshake Message**   （第四个TCP）

  12. 双方验证加密解密都OK，TLS握手结束

* 通信

  后续通信的内容，都通过**对称加密算法**和**会话秘钥**来加密和解密

  

![1](p\img_4.png)

### ECDHE和RSA的不同点

* ECDHE可以"抢跑"，客户端发送完"Finished",并收到ACK就可以开始发送HTTP报文，不需要等Server返回"Finished"

* ECDHE的pre-master是通过Server Params和Client Params，利用ECDHE算法计算来的,可以明文传输

  RSA的pre-master是Client随机生成的，必须用Server的公钥加密传输
