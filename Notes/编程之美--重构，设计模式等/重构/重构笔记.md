- [**重构的第一步**](#重构的第一步)
- [**代码的坏味道**](#代码的坏味道)
- [**优化方法**](#优化方法)
#### **重构的第一步**

为即将修改的代码建立一组可靠的测试，这些测试必须有自我检验能力

重构以微小的步伐修改程序，每次修改后都要运行一次测试



消除重复代码——可以确定所有的事务和行为在代码中只表述一次，这是优秀设计的根本





#### **代码的坏味道**

1. 命名问题

2. 重复代码

3. 过长的方法

   每当感觉需要以注释来说明点什么的时候——采用**提炼函数**，把需要说明的东西写进一个独立的方法，并用其用途去命名

4. 条件表达式和循环是提炼方法的信号

   * 条件表达式
     * switch语句，每个分支的条件表达式都应该提炼成函数（第一种方式）
     * switch，可以用**多态取代表达式的方式**取代掉
   * 循环
     * 应该将循环和循环内的代码提炼到一个独立的方法中

5. 过长的参数列表

6. 全局数据，类变量

   变量应该被封装起来

7. 发散式变化

   我们希望只在系统的某一处进行修改，如果某个变化，需要在多处进行修改，就是**发散式变化**——坏味道

8. 散弹式修改

   如果遇到某种变化，需要在不同类中进行很多小修改，这就是 散弹式修改

   这种情况下，可以**搬移函数**和**搬移字段**，将所有需要修改的代码放入同一个模块内

9. 移情别恋

   一个方法跟其他类中的方法或者数据交流更频繁，远胜自己所处模块内的交流

   此时，应该进行**搬移函数**，将这个方法移过去

10. 数据泥团

    一些数据经常捆绑出现——数据泥团

    经常绑在一起出现的数据应该拥有属于他们自己的对象——用**提炼类**的方法将它们提炼到一个独立对象中

    判断方法：删掉众多数据中的一项。如果这么做，其他数据有没有因而失去意义？如果它们不再有意义，这就是一个明确信号：你应该为它们产生一个新对象。

11. 过长的消息链

    用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链

12. 中间人过度委托

    封装伴随着委托

    ```
    例如：问主管是否有时间参加一个会议，他就把这个消息“委托”给他的记事簿，然后才能回答你。很好，你没必要知道这位主管到底使用传统记事簿还是使用电子记事簿抑或是秘书来记录自己的约会。
    ```

    但如果有一个类，它有一半的方法都委托其他类，那就是**过度委托**，可以考虑把这个类（中间人）移除掉

13. 模块之间交换数据过于频繁

14. 过大的类





#### **优化方法**

1. 提炼函数

   将代码放入一个独立函数中，并用函数名来阐述函数的用途

2. 变量名优化

   通过变量名增加代码可读性

3. 方法应该放在**它所使用的数据所属的类**中

   ```
   方法method(A a)，仅使用了a作为参数，那么method(A a)应该属于类A
   或者method()中使用的数据，大多来自类A，那么method()应该属于类A
   ```

4. 内联函数

   在函数调用点插入函数本体，然后移除该函数

   ```
   原：
   int getRating(){
      return (moreThanFiveLateDeliveries())?2:1;
   }
   boolean moreThanFiveLateDeliveries(){
      return numberOfLateDeliveries>5;
   }
   
   改进：
   int getRating(){
      return (numberOfLateDeliveries>5)?2:1;
   }
   ```

5. 内联临时变量

   将对所有临时变量的引用动作，替换成对该临时变量赋值的表达式

   ```
   原:
   double basePrice=anOrder.basePrice();
   return (basePrivce>1000);
   
   改进：
   return (anOrder.basePrice()>1000);
   ```

6. Replace Temp with Query

   将表达式提炼到一个独立函数中，将对临时变量的引用都替换为对该函数的调用

   ```
   原：
   double basePrice=quantity*itemPrice;
   if(basePrice>1000)
      return basePrice*0.95;
   else: 
      return basePrice*0.85;
   改：
   if(basePrice()>1000){
      return basePrice()*0.95;
   }
   else
      return basePrice()*0.85;
      
   double basePrice(){
       return quantity*itemPrice;
   }
   ```

   

7. 引入解释性变量

   将复杂表达式的结果放入一个临时变量，以变量名来阐述该表达式的用途

   ```
   原:
   if((platform.toUpperCase().indexOf("MAC")>-1)&&
      (browser.toUpperCase().indexOf("IE")>-1)&&
      (wasInitialized()&& resize>0)
   {
   //do something
   }
   改:
   final boolean isMacOs    =platform.toUpperCase().indexOf("MAC")>-1;
   final boolean isIEBrowser=browser.toUpperCase().indexOf("IE")>-1;
   final boolean wasResized =resize>0;
   if (isMacOs && isIEBrowser && wasInitialized() && wasResized)
   {
   //do something
   }
   ```

   

8. 分解临时变量

   如果有个临时变量被赋值超过一次，并且它不是循环遍历，也不用于收集计算结果

   那么针对每次复制，创建一个独立的临时变量

9. 不能对参数进行复制

   如果代码需要对参数进行复制，应该创建一个临时变量来代替参数进行操作

   