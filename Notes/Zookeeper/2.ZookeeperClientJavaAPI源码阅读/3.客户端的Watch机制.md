### **整体逻辑**

![watch机制1](p\4.png)

1. Client向Zookeeper服务端发送Watch，进行注册
2. 同时Client还会把Watch存储到WatchManager中
3. Zookeeper服务端触发Watch时间时，会向Client发送通知，Client依据通知从WatchManager中取出对应的Watcher对象来执行**回调逻辑**

------



### **Watcher接口**

```
public interface Watcher {
    void process(WatchedEvent event);

}

```

* **内部类**

  * **Event接口**

    * **KeeperState枚举类**

      通知状态

    * **EventType枚举类**

      时间类型

  * **WatcherType枚举类**

    枚举了触发的Watcher类型

* **方法**

  * **void process(WatchedEvent event)**

    接受一个WatchedEvent对象，进行回调

  

### **WatchedEvent**

```
public class WatchedEvent {

    private final KeeperState keeperState;
    private final EventType eventType;
    private String path;

    /**
     *  Convert WatchedEvent to type that can be sent over network
     */
    public WatcherEvent getWrapper() {
        return new WatcherEvent(eventType.getIntValue(), keeperState.getIntValue(), path);
    }

}
```

* **WatchedEvent无法进行网络传输，但是WatcherEvent实现了序列化接口，可以进行网络传输**

  Server检测到事件触发，生成一个WatchedEvent对象，然后调用其getWrapper()方法，将WatchedEvent对象转换为可序列化的WatcherEvent对象，将WatcherEvent对象发送给Client

  Client接收到WatcherEvent对象后，再将其装换为WatchedEvent对象，并将其传递给process处理

  ------

  



### **客户端Watch注册和存储**

![watch机制1](p\2.png)

Watcher发送的时候与两个类——**WatchRegistration**和**ZKWatchManager**有很大的关系

1. Wathcer会封装为WatchRegistration对象，然后WatchRegistration对象会封装进Packet对象中
2. Packet对象发送outgoing队列后，会有SendThread发送给服务器，服务器上会实现该Watcher的注册
3. SendThread接收到服务器的响应后，会从Packet对象中取出WatchRegistration对象，然后调用其**register()**，将WatchRegistration中的Watcher交由ZKWatchManager保管

### **服务器处理Watcher**

### **服务器触发Watcher**

### **客户端回调**





### 
