[TOC]



### 1. Zookeeper Client介绍与类图

#### 1.1 Zookeeper Client介绍

* **每创建一个Zookeeper对象，就是成功创建了一个与服务器连接的客户端**

* **Zookeeper提供的API有同步和异步两种模式**
  * 调用同步API，Client的线程会阻塞，直到收到Server的响应结果(不管是否成功)
  * 调用异步API，Client会从API返回，继续干自己的事情，Server返回响应结果时(不管是否成功)会通知Client（通过一个Callback对象）

#### 1.2 Zookeeper Client方法调用流程图

![2](p/2.png)

#### 1.3 Zookeeper Client类图结构

![Client类结构.drawio](p/Client类结构.drawio.png)

* SendThread：负责向服务器发送Packet，接受服务器响应
* EventThread：处理事件通知，调用Watcher的回调函数



### 1. Zookeeper Watcher机制

#### 1.0 Watcher机制整体逻辑

![watch机制1](p/4.png)

1. Client向Zookeeper服务端发送Watch，进行注册
2. 同时Client还会把Watch存储到WatchManager中
3. Zookeeper服务端触发Watch时间时，会向Client发送通知，Client依据通知从WatchManager中取出对应的Watcher对象来执行**回调逻辑**

#### 1.1 Client注册和存储Watcher

![watch机制1](p/2.png)

1. Wathcer会封装为WatchRegistration对象，然后WatchRegistration对象会封装进Packet对象中
2. Packet对象发送outgoing队列后，会有SendThread发送给服务器，服务器上会实现该Watcher的注册
3. SendThread接收到服务器的响应后，会从Packet对象中取出WatchRegistration对象，然后调用其**register()**，将WatchRegistration中的Watcher交由ZKWatchManager保管

#### 1.2 Wathcer在Server端的存储

![Server存储Watcher机制.drawio](p/Server存储Watcher机制.drawio.png)



最终，ServerCnxn（Watcher）存放到了DataTree的WatcherManager中的watchTables和watch2Paths

**Zookeeper服务器端，其实是把ServerCnxn当做Watcher进行存储**

#### 1.3 Server端触发Watcher

以setData()触发Watcher举例

setData()方法最终会调用 **DataTree的setData()方法**，而Watcher的触发就在这setData()中

![Server上Watcher的触发](p/Server上Watcher的触发.png)

#### 1.4 Client回调Watcher

![Client触发Watcher](p/Client触发Watcher.png)

watingEvent是一个阻塞等待队列，EventThread的run()会不断对处理该队列中的对象

EventThread的run()会从watingEvent中取出WatcherSetEventPair，从中取得Set<Wather>和WatchedEvent ,然后逐个执行执行每个Watcher的process()

```java
public void run() {
    try {
        isRunning = true;
        while (true) {
            Object event = waitingEvents.take();//从watingEvents中取出WatcherSetEventPair
            if (event == eventOfDeath) {
                wasKilled = true;
            } else {
                processEvent(event);//处理WatcherSetEventPair
            }
            if (wasKilled) {
                synchronized (waitingEvents) {
                    if (waitingEvents.isEmpty()) {
                        isRunning = false;
                        break;
                    }
                }
            }
        }
    } catch (InterruptedException e) {
        LOG.error("Event thread exiting due to interruption", e);
    }
}

private void processEvent(Object event) {
    try{
        if (event instanceof WatcherSetEventPair) {
            // 处理WatcherSetEventPair
            WatcherSetEventPair pair = (WatcherSetEventPair) event;
            for (Watcher watcher : pair.watchers) {//从WatcherSetEventPair中取出Set<Watcher>
                try {
                    watcher.process(pair.event);//逐个回调
                } catch (Throwable t) {
                    LOG.error("Error while calling watcher.", t);
                }
            }
        }
    }//以下代码略
}
```

