重入锁ReentrantLock   
* 可重入锁，即该锁支持一个线程对资源重复加锁  
* 支持公平锁和非公平锁  
   * 公平锁：先对锁进行请求的线程先获得锁(先到先得)
   * 非公平锁 ：没有先到先得，可以插队  
    
* ReentrantLock除了实现Lock接口的方法外，还实现了以下方法   
    ```java
    //查询当前线程保持此锁的次数。
    int getHoldCount() 
    
    //返回目前拥有此锁的线程，如果此锁不被任何线程拥有，则返回 null。      
    protected  Thread   getOwner(); 
    
    //返回一个 collection，它包含可能正等待获取此锁的线程，其内部维持一个队列，这点稍后会分析。      
    protected  Collection<Thread>   getQueuedThreads(); 
    
    //返回正等待获取此锁的线程估计数。   
    int getQueueLength();
    
    // 返回一个 collection，它包含可能正在等待与此锁相关给定条件的那些线程。
    protected  Collection<Thread>   getWaitingThreads(Condition condition); 
    
    //返回等待与此锁相关的给定条件的线程估计数。       
    int getWaitQueueLength(Condition condition);
    
    // 查询给定线程是否正在等待获取此锁。     
    boolean hasQueuedThread(Thread thread); 
    
    //查询是否有些线程正在等待获取此锁。     
    boolean hasQueuedThreads();
    
    //查询是否有些线程正在等待与此锁有关的给定条件。     
    boolean hasWaiters(Condition condition); 
    
    //如果此锁的公平设置为 true，则返回 true。     
    boolean isFair() 
    
    //查询当前线程是否保持此锁。      
    boolean isHeldByCurrentThread() 
    
    //查询此锁是否由任意线程保持。        
    boolean isLocked()
    ```