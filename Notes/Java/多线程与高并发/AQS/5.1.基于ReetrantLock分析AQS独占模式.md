ReetrantLock 
  * Sync : 定义了抽象方法lock(),实现了tryRelease()
    * FairSync ： 公平锁，实现了lock(),tryAcquire()
    * NonfairSync ： 非公平锁，实现了lock(),tryAcquire()  
    

* ReentrantLock中的几个比较重要的属性和方法 
```java
    public class ReentrantLock implements Lock, java.io.Serializable {
        private final Sync sync;
    
        public ReentrantLock() {
            sync = new NonfairSync();
        }
    
        public ReentrantLock(boolean fair) {
            sync = fair ? new FairSync() : new NonfairSync();
        }
    
        public void lock() {
            sync.lock();
        }
    
        public void unlock() {
            sync.release(1);
        }
    }
```
  
* 内部抽象类Sync
```java
    abstract static class Sync extends AbstractQueuedSynchronizer {
            //定义上锁操作
            abstract void lock();
            
            //实现释放锁操作
            protected final boolean tryRelease(int releases) {
                int c = getState() - releases;
                if (Thread.currentThread() != getExclusiveOwnerThread())
                    throw new IllegalMonitorStateException();
                boolean free = false;
                if (c == 0) {
                    free = true;
                    setExclusiveOwnerThread(null);
                }
                setState(c);
                return free;
            }
            
            //判断当前线程是否为锁的持有线程
            protected final boolean isHeldExclusively() {
                return getExclusiveOwnerThread() == Thread.currentThread();
            }
        }
```
  
* 内部类NonfairSync非公平锁
```java
        static final class NonfairSync extends Sync { 
            //实现上锁操作
            final void lock() {
                //上锁=获取锁+占有锁
                //执行CAS操作,查看state的值，
                // 若state为0，将state替换为1，获取锁，返回true
                // 若state为1，CAS失败，未取得锁，返回false
                if (compareAndSetState(0, 1))
                    //CAS成功，占有锁，将锁的持有线程替换为当前线程
                    setExclusiveOwnerThread(Thread.currentThread());
                else
                    //CAS失败，再次获取锁
                    acquire(1);
            }
    
            //实现获取锁操作
            protected final boolean tryAcquire(int acquires) {
                return nonfairTryAcquire(acquires);
            }
        }
```  

再次请求锁时，如果请求成功给state设置为arg  
    
* 内部类FairSync公平锁 
```java
        static final class FairSync extends Sync {
            //实现上锁操作
            final void lock() {
                acquire(1);
            }
            
            //实现获取锁操作
            protected final boolean tryAcquire(int acquires) {
                final Thread current = Thread.currentThread();
                int c = getState();
                if (c == 0) {
                    if (!hasQueuedPredecessors() &&
                            compareAndSetState(0, acquires)) {
                        setExclusiveOwnerThread(current);
                        return true;
                    }
                }
                else if (current == getExclusiveOwnerThread()) {
                    int nextc = c + acquires;
                    if (nextc < 0)
                        throw new Error("Maximum lock count exceeded");
                    setState(nextc);
                    return true;
                }
                return false;
            }
        }
```