
## 1. Redis实现分布式锁

**上锁**和 **释放锁**都必须保证是 **原子操作**

### 1.1 上锁

> set lock_key  unique_value  [EX seconds|PX milliseconds]  NX
>
> * 创建成功就是取得锁
>
> * 设置过期时间——防止客户端上完锁后发生异常造成死锁
> * NX——只有key不存在才能创建成功，只有锁没有被其他线程获取才能尝试获得锁
>
> * unique_value为获得锁的客户端的唯一标识——区分不同的客户端，防止锁被其他客户端误删

### 1.2 释放锁

* 释放锁时，客户端要检查锁的value是否为自己的唯一标识，是的话才能释放锁（释放锁

  > A获得锁，但是A超时了，锁自动释放，然后B获得锁，A执行完后，不检查value是否为自己的唯一标识就直接释放锁的话，就会错误的释放B的锁



释放锁必须是**原子操作**，我们使用**Lua脚本**来实现

```lua
if redis.call("get",KEYS[1])==ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

### 1.3 存在的问题

* 如果A获得锁后，锁过期了，还没处理完任务，那么锁就会超时消失，这时，A还在访问共享数据，但是B获得锁，也来访问共享数据
* 单点问题，如果线程A加锁成功后，锁还未从master复制到slave，master挂了，slave升级为master，那么线程B此时也可以获得锁，会出现同一资源被多个client访问的情况



## 2. 分布式锁过期了,任务还没处理完

> 如果A获得锁后，锁过期了，还没处理完任务，那么锁就会超时消失，这时，A还在访问共享数据，但是B获得锁，也来访问共享数据



### 2.1 解决方法

对于该问题有三种**解决方法**

* 为过期时间设置一个合理的值（预防）

* 守护线程 “续命”——另外起一个线程，定期检查锁的失效时间，如果锁快要过期了，但是操作还没有执行完，那么自动为锁续命（Redission实现方案）

  > Redisson 里面就实现了这个方案，使用“看门狗”定期检查（每1/3的锁时间检查1次），如果线程还持有锁，则刷新过期时间。

* 超时回滚——线程获得锁后执行任务耗时过长导致锁自动消失了，那么线程在删除锁时会发现锁已经被其他线程获取了，那么此时执行的操作是不安全的，需要进行回滚，并返回失败



### 2.2 守护线程续命存在的问题

Redisson 使用看门狗（守护线程）“续命”的方案在大多数场景下是挺不错的，也被广泛应用于生产环境，但是在极端情况下还是会存在问题。

问题例子如下：

1. 线程1首先获取锁成功，将键值对写入 redis 的 master 节点
2. 在 redis 将该键值对同步到 slave 节点之前，master 发生了故障
3. redis 触发故障转移，其中一个 slave 升级为新的 master
4. 此时新的 master 并不包含线程1写入的键值对，因此线程2尝试获取锁也可以成功拿到锁
5. 此时相当于有两个线程获取到了锁，可能会导致各种预期之外的情况发生，例如最常见的脏数据

解决方法：上述问题的根本原因主要是由于 redis 异步复制带来的**数据不一致问题**导致的，**因此解决的方向就是保证数据的一致**

当前比较主流的解法和思路有两种：

* **RedLock**
* **Zookeeper实现的分布式锁**



## 3. RedLock

RedLock中对Redis实例加锁和解锁跟上面讲的是一样的



假设我们有 N 个 Redis 主节点，例如 N = 5（至少5个实例），这些节点是完全独立的（不是Redis Cluster），为了取到锁，客户端应该执行以下操作:

1. 获取当前时间

2. 客户端按顺序依次向N个Redis实例执行加锁操作

   > 这里加锁时要设置超时时间(超时时间要小于锁失效时间，如果锁失效时间为10s，那么超时时间在5-50毫秒之间)——访问客户端与一个宕机的Redis实例长时间因长时间尝试通信而处于阻塞状态，如果一个Redis实例不可用，客户端应尽快尝试下一个Redis实例

3. 一旦客户端对N个Redis实例都完成加锁操作，客户端会计算整个加锁过程的耗时，只有满足以下2个条件才会认为加锁成功

   * 客户端从超过半数(>=N/2+1)的Redis实例上成功获得锁
   * 整个加锁过程的耗时<锁的有效时间

4. 如果加锁成功——重新计算锁的有效时间（初始有效时间-加锁过程的耗时）

   如果加锁失败——客户端在所有Redis实例上进行解锁操作

   如果加锁成功，但是锁的有效时间已经来不及完成共享数据的操作——客户端在所有Redis实例上进行解锁操作



该方案看着挺美好的，但是实际上我所了解到的在实际生产上应用的不多，主要有两个原因：1）该方案的成本似乎有点高，需要使用5个实例；2）该方案一样存在问题。

该方案主要存以下问题：

1. **严重依赖系统时钟**。如果线程1从3个实例获取到了锁，但是这3个实例中的某个实例的系统时间走的稍微快一点，则它持有的锁会提前过期被释放，当他释放后，此时又有3个实例是空闲的，则线程2也可以获取到锁，则可能出现两个线程同时持有锁了。
2. 如果线程1在3个实例成功执行加锁操作，获取到了锁，但是其中有1台重启了，则此时又有3个实例上是没有锁的，那么线程2也可以获取到锁，此时又出现两个线程同时持有锁了
2. 如果线程1成功获得锁后，因为GC阻塞或者业务逻辑耗时过长，导致锁失效了，线程2也可以获得锁，导致多个线程同时操作共享资源



## 4. Redisson封装的锁

* 可重入锁
* 乐观锁
* 公平锁
* 读写锁
* RedLock
