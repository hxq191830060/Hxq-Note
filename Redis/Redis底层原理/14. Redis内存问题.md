# 1. 内存消耗

## 1.1 Redis进程内的内存消耗

Redis进程内的内存消耗划分为

* 自身内存(Redis空进程占用内存)
* 对象内存
* 缓冲内存
* 内存碎片

### 1.1.1 自身内存

Redis空进程占用内存（非常少，3MB左右）

### 1.1.2 对象内存

存储所有的数据——所有的key-value

### 1.1.3 缓冲内存

* 客户端缓冲
  * 客户端输入缓冲区
  * 客户端输出缓冲区
* 复制积压缓冲区
* AOF缓冲区
  * aof_buf
  * aof_rewrite_buf

### 1.1.4 内存碎片

* 第一个原因
  
  Redis默认的内存分配器为 jemalloc
  
  jemalloc将内存空间划分为
  
  * 小——[8b]，[16b，32b，48b，...... ，128b]，[192b，256b，...... ，512b]，[768b，1024b，...... ，3840b]
  * 大——[4KB，8KB，12KB，...... ，4072KB]
  * 巨大——[4MB，8MB，12MB，......]
  
  比如保存5KB的对象，jemalloc可能会采用8KB的内存块来鵆，剩下的3KB空间就成为了内存碎片

* 第二个原因
  
  键值对修改，会导致空间的扩容和释放
  
  * 修改后键值对变大了——空间预分配机制，可能会导致内存碎片的产生
  * 修改后键值对变小了——原本分配的空间会有一部分空闲，形成内存碎片

#### 内存碎片带来的问题

删除键值对后，这些内存会交由内存分配器管理，不会立即返回给操作系统，操作系统仍然记录着Redis分配了这些内存

### 清除内存碎片

1. 重启Redis

2. 自动清除
   
   * **active-defrag-ignore-bytes 100mb**：内存碎片达到100MB，开始清理
   * **active-defrag-threshold-lower 10**：内存碎片空间占操作系统分配给Redis的总空间的10%，开始清除
   
   清除内存碎片在一定程度上会影响性能，所有Redis还提供了2个参数
   
   * **active-defrag-cycle-min 25**：自动清理过程所占用CPU时间的比例不低于25%，保证清理正常开展
   * **active-defrag-cycle-max 75**：自动清理过程中所用CPU时间的比例不高于75%，一旦超过，净停止清除

## 1.2 子进程内存消耗

子进程内存消耗——执行AOF重写，RDB持久化时Redis通过fork操作创建子进程的内存消耗

* fork操作产生的子进程内存占用量对外变现为与父进程相同，理论上需要一倍的物理内存
* Linux有 **写时复制技术(copy-on-write)**，父进程与子进程共享相同的物理内存页
  * 父进程处理写请求时为需要修改的页创建副本，然后在副本上完成写请求
  * 子进程依然读取fork时整个父进程的内存快照

#### THP机制对子进程内存消耗的影响

Linux Kernel在2.6.38内核中增加了 **Transparent Huge Pages(THP)机制**

* 降低了fork的耗时
* copy-on-write期间，复制内存页的单位由4KB变为2MB——如果父进程有大量写命令，会加重内存拷贝量

**建议关闭THP——防止copy-on-write期间内存过度消耗**

# 2. 内存管理

## 2.1 设置内存上限

Redis使用 **maxmemory参数限制最大可用内存**

* 超过内存上限maxmemory时使用LRU等内存回收策略释放空间
* 防止所用内存超过服务器物理内存

## 2.2 内存回收

Redis内存回收机制体现在两方面

* **删除过期的键**
* **内存使用达到maxmemory时触发内存回收**

### 2.2.1 删除过期的键

Redis有两种**过期键删除策略**—— **惰性删除** 和 **定时删除**

#### 2.2.1.1 惰性删除

主节点每次处理读命令时，都会检查key是否超时，如果超时——执行del命令删除key，然后将del命令异步发送给从节点

* 优点——对CPU时间友好

* 缺点——有内存泄漏的问题

#### 2.2.1.2 定时删除

Redis内部维护一个定时任务(每秒10次)

1. 在每个数据库空间随机检查20个key，当发现过期的key时将其删除

2. 如果检查到超过25%的key过期，那么循环执行回收逻辑直到不足25%或者超时（25ms）
* 优点——减少删除操作对CPU的影响

* 缺点——难以确定删除操作执行的时长

#### 2.2.1.3 从节点的过期策略

* 从节点不会进行过期扫描，从节点对过期键值对的处理是被动的，主节点检测到过期键值对后将其删除，同步一条del命令给从节点

* 在Redis3.2前，可以从Redis从节点上读取到过期的键值对

* 在Redis3.2后，从节点在每次读取数据之前会检查key的过期时间来决定是否返回

## 2.3 内存回收策略

Redis所使用的内存达到maxmemory上限会触发响应的内存溢出控制策略——受**参数maxmemory-policy**控制

* **noeviction**：默认策略，不会删除任何数据，拒绝所有写请求

* **volatile-ttl**：在设置了过期时间的key中，淘汰过期时间剩余最短的，如果不够，回退到 noeviction策略

* **random**
  
  * - **allkeys-random**：随机删除所有key，直到腾出足够空间位置
    - **volatile-random**：从设置了过期时间的key中随机淘汰，直到腾出足够空间位置

* **LRU**
  
  * **allkeys-lru**：根据LRU算法删除所有key，直到腾出足够位置为止
  
  * **volatile-lru**：根据**LRU算法**删除设置了过期时间的key，直到腾出足够空间位置，如果没有可删除的key，回退到 noeviction策略

* **LFU**
  
  * **allkeys-lfu（新）**：根据LFU算法删除所有key，直到腾出足够位置为止
  
  * **volatile-lfu（新）**：根据**LFU算法**删除设置了过期属性的key，直到腾出足够空间位置，如果没有可删除的key，回退到 **noeviction策略**

**如果Redis一直工作在内存溢出的状态下并且设置了非noeviction策略——会频繁触发回收内存的操作，影响Redis性能**

#### 2.3.1 LRU

LRU——Least Recently Used，按照最近最少使用的原则来筛选数据，将最不常用的数据筛选出来

* **正常的LRU**
  
  维护一个链表，链表头部是最近被访问的元素，尾部是最久没被访问的元素
  
  当空间满时，会剔除掉链表尾部的元素

* **Redis的LRU**
  
  * **Redis3.0前**
    
    正常的LRU算法会消耗大量内存，并且涉及链表移动，很耗时
    
    Redis的key，value都是通过redisObject来封装的
    
    redisObject中有一个lru字段，记录了该数据最后一次被访问的时间
    
    Redis第一次决定淘汰数据时，会随机选出N个(默认5个)数据，组成一个候选集，然后比较这N个数据的lru字段，将最旧的数据剔除   
    
    后续要再淘汰数据时，Redis挑选数据放入候选集（挑选标准是该数据的lru < min(候选集中的所有lru) ），然后将候选集中lru最小的数据淘汰出去
  
  * **Redis3.0后**
    
    引入了缓冲池(pool,默认16)
    
    整个流程相当于随机取 5 个 key ，如果key的空闲时间大于pool中所有key的空闲时间，放入 pool，然后淘汰 pool 中空闲时间最大的 key，然后再随机取 5 个 key放入 pool，继续淘汰 pool 中空闲时间最大的 key，一直持续下去。
    
    在进入淘汰前会计算出需要释放的内存大小，然后就一直循环上述流程，直至释放足够的内存。

#### 2.3.2 LFU

LFU——Least Frequently Userd，最近最少使用

LFU模式下

redisObject的lru字段(24b)划分为

* ldt(last decrememt time) 高16b——计数器最后一次衰减的时间戳

* logc(logistic counter) 低8b——访问频率，采用特殊的计数规则，同时还有**衰减机制**
  
  * **计数规则**
    数据每被访问一次，计算**p=1/(当前访问频率* lfu_log_factor+1)**，然后随机生成一个(0,1)的随机数r，只有p>r时，访问频率才+1     
    lfu_log_factor:对数因子，默认为10   
  
  * **衰减机制**
    
    使用 **配置lfu_decay_time**来控制counter的衰减
    
    LFU会计算当前时间和上一次衰减的时间差，然后将该差值除以 lfu_decay_time，得到的结果是counter要衰减的值
