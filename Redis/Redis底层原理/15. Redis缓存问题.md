# 1. 缓存穿透

用户查询一个数据，Redis中没有(缓存没命中)，于是向持久层数据库查询，持久层数据库也没有，并且不将空结果写入缓存

当这样的查询很多时，缓存都没有命中，于是都去请求持久层数据库，失去了缓存保护后端持久层的意义，这就是缓存穿透

## 1.1 缓存空值

当存储层未命中后，即使返回空值也存储起来，并设置一个过期时间

* 存在的问题
  
  * Redis需要更多的内存去存储空值
  
  * 可能会导致Redis与数据库不一致（Redis缓存了空值，但是有用户在数据库插入了新的值）

## 1.2 Bloom Filter

通过Bloom Filter判断key是否在数据库中，不存在就直接返回，避免了对底层存储系统的查询压力

# 2. 缓存击穿

缓存击穿——指的是一个key非常热点，并发量很大

这个key过期的瞬间，大量的请求并发访问持久层数据库，导致数据库瞬间压力过大，可能让应用崩溃

## 2.1 热点数据永不过期

不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间

* 缺点——会出现缓存和数据库数据不一致，并且代码复杂

## 2.2 互斥锁

当热点key过期时，让各个用户请求去争夺互斥锁，获得锁的用户请求可以直接访问数据库，其他用户线程要么等待锁释放后重新访问缓存，要么返回默认值

# 3. 缓存雪崩

1. 大量缓存数据在同一时间过期（失效）时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是缓存雪崩

2. Redis宕机

## 3.1 缓存中有大量数据同时过期

* 将过期时间打散

* 设置缓存不失效

* 数据预热——在大流量到达前重新设置过期时间

* 服务降级
  
  * 非核心业务暂停对缓存的访问，直接返回预定义好的信息
  
  * 核心业务正常访问缓存，如果缓存确实，去持久层获取数据

## 3.2 Redis宕机

* 服务熔断
  
  * 暂停业务系统对缓存的调用，直到缓存恢复

* 请求限流
  
  * 允许少量请求直接访问数据库

# 4. 缓存污染

有些数据访问次数非常少，如果这样的数据留在内存中，只会白白占用缓存空间——这就是缓存污染

**我们可以通过设置缓存回收策略解决**

## 4.1 LRU缓存策略

LRU只会关注数据最近一次被访问的时间，在处理 **扫描式单次查询**时，无法解决缓存污染

**扫描时单次查询**——对大量数据进行一次全体读取，每个数据都会被读取，而且只会被读取一次

使用LRU，这些数据会在缓存中存在很长一段时间，造成缓存污染

## 4.2 LFU缓存策略

所以正确的做法应该是使用LFU缓存策略
