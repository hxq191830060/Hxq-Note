[toc]

# 1. 内存消耗

## 1.1 Redis进程内的内存消耗

Redis进程内的内存消耗划分为

* 自身内存(Redis空进程占用内存)
* 对象内存
* 缓冲内存
* 内存碎片

### 1.1.1 自身内存

Redis空进程占用内存（非常少，3MB左右）

### 1.1.2 对象内存

存储所有的数据——所有的key-value

### 1.1.3 缓冲内存

* 客户端缓冲
  * 客户端输入缓冲区
  * 客户端输出缓冲区
* 复制积压缓冲区
* AOF缓冲区
  * aof_buf
  * aof_rewrite_buf

### 1.1.4 内存碎片

* 第一个原因

  Redis默认的内存分配器为 jemalloc

  jemalloc将内存空间划分为

  * 小——[8b]，[16b，32b，48b，...... ，128b]，[192b，256b，...... ，512b]，[768b，1024b，...... ，3840b]
  * 大——[4KB，8KB，12KB，...... ，4072KB]
  * 巨大——[4MB，8MB，12MB，......]

  比如保存5KB的对象，jemalloc可能会采用8KB的内存块来鵆，剩下的3KB空间就成为了内存碎片

* 第二个原因

  键值对修改，会导致空间的扩容和释放

  * 修改后键值对变大了——空间预分配机制，可能会导致内存碎片的产生
  * 修改后键值对变小了——原本分配的空间会有一部分空闲，形成内存碎片

  

#### 内存碎片带来的问题

删除键值对后，这些内存会交由内存分配器管理，不会立即返回给操作系统，操作系统仍然记录着Redis分配了大量的内存



### 清除内存碎片

1. 重启Redis

2. 自动清除

   * **active-defrag-ignore-bytes 100mb**：内存碎片达到100MB，开始清理
   * **active-defrag-threshold-lower 10**：内存碎片空间占操作系统分配给Redis的总空间的10%，开始清除

   清除内存碎片在一定程度上会影响性能，所有Redis还提供了2个参数

   * **active-defrag-cycle-min 25**：自动清理过程所占用CPU时间的比例不低于25%，保证清理正常开展
   * **active-defrag-cycle-max 75**：自动清理过程中所用CPU时间的比例不高于75%，一旦超过，净停止清除

## 1.2 子进程内存消耗

子进程内存消耗——执行AOF重写，RDB持久化时Redis通过fork操作创建子进程的内存消耗

* fork操作产生的子进程内存占用量对外变现为与父进程相同，理论上需要一倍的物理内存
* Linux有 **写时复制技术(copy-on-write)**，父进程与子进程共享相同的物理内存页
  * 父进程处理写请求时为需要修改的页创建副本，然后在副本上完成写请求
  * 子进程依然读取fork时整个父进程的内存快照

#### THP机制对子进程内存消耗的影响

Linux Kernel在2.6.38内核中增加了 **Transparent Huge Pages(THP)机制**

* 降低了fork的耗时
* copy-on-write期间，复制内存页的单位由4KB变为2MB——如果父进程有大量写命令，会加重内存拷贝量

**建议关闭THP——防止copy-on-write期间内存过度消耗**



# 2. 内存管理

## 2.1 设置内存上限

Redis使用 **maxmemory参数限制最大可用内存**

* 超过内存上限maxmemory时使用LRU等内存回收策略释放空间
* 防止所用内存超过服务器物理内存



## 2.2 内存回收策略

Redis内存回收机制体现在两方面

* **删除过期的键**
* **内存使用达到maxmemory时触发内存溢出控制策略**



### 2.2.1 删除过期的键

Redis有两种**过期键删除策略**—— **惰性删除** 和 **定时删除**



#### 2.2.1.1 惰性删除

主节点每次处理读命令时，都会检查key是否超时，如果超时——执行del命令删除key，然后将del命令异步发送给从节点

**有内存泄漏的问题——过期key一直没有被访问，那么其内存就无法被及时释放**



#### 2.2.1.2 定时删除

Redis内部维护一个定时任务(每秒10次)

1. 默认采用慢模式运行——定时任务在每个数据库空间随机检查20个key，当发现过期的key时删除
2. 如果检查到超过25%的key过期，那么循环执行回收逻辑直到不足25%或者超时（慢模式下超时时间为25毫秒）
3. 如果第2步超时了——那么采用快模式（快模式下超时时间为1毫秒，且2s内只运行1次）

#### 2.2.1.3 从节点的过期策略

**从节点永远不会主动删除超时数据，但是在Redis3.2后，从节点在每次读取数据之前会检查key的过期时间来决定是否返回**

主节点发现key过期时，会删除掉key，然后将del指令发送给从节点



## 2.3 内存溢出控制策略

Redis所使用的内存达到maxmemory上限会触发响应的内存溢出控制策略——受**参数maxmemory-policy**控制

* **noeviction**：默认策略，不会删除任何数据，拒绝所有写请求
* **allkeys-random**：随机删除所有key，直到腾出足够空间位置
* **allkeys-lru**：根据LRU算法删除key，不管key有没有设置超时属性，直到腾出足够位置为止
* **allkeys-lfu（新）**：根据LFU算法删除key，不管key有没有设置超时属性，直到腾出足够位置为止
* **volatile-random**：随机删除过期键，直到腾出足够空间位置
* **volatile-ttl**：根据key的ttl属性，删除最近将要过期的数据，如果没有，回退到 **noeviction策略**
* **volatile-lru**：根据**LRU算法**删除设置了超时属性的key，直到腾出足够空间位置，如果没有可删除的key，回退到 **noeviction策略**
* **volatile-lfu（新）**：根据**LFU算法**删除设置了超时属性的key，直到腾出足够空间位置，如果没有可删除的key，回退到 **noeviction策略**

**如果Redis一直工作在内存溢出的状态下并且设置了非noeviction策略——会频繁触发回收内存的操作，影响Redis性能**



#### 2.3.1 LRU

LRU——Least Recently Used，按照最近最少使用的原则来筛选数据，将最不常用的数据筛选出来

* **正常的LRU**

  维护一个链表，链表头部是最近被访问的元素，尾部是最久没被访问的元素

  当空间满时，会剔除掉链表尾部的元素

* **Redis的LRU**

  * **Redis3.0前**

    正常的LRU算法会消耗大量内存，并且涉及链表移动，很耗时

    Redis的key，value都是通过redisObject来封装的

    redisObject中有一个lru字段，记录了该数据最后一次被访问的时间

    Redis第一次决定淘汰数据时，会随机选出N个(默认5个)数据，组成一个候选集，然后比较这N个数据的lru字段，将最旧的数据剔除   
  
    后续要再淘汰数据时，Redis挑选数据放入候选集（挑选标准是该数据的lru < min(候选集中的所有lru) ），然后将候选集中lru最小的数据淘汰出去
  
  * **Redis3.0后**
  
    引入了缓冲池(pool,默认16)
  
    当每一轮移除 key 时，拿到了 N（默认5）个 key 的 idle time，遍历处理这 N 个 key，如果 key 的 idle time 比 pool 里面的 key 的 idle time 还要大，就把它添加到 pool 里面去。
  
    当 pool 放满之后，每次如果有新的 key 需要放入，需要将 pool 中 idle time 最小的一个 key 移除。这样相当于 pool 里面始终维护着还未被淘汰的 idle time 最大的 16 个 key。
  
    当我们每轮要淘汰的时候，直接从 pool 里面取出 idle time 最大的 key（只取1个），将之淘汰掉。
  
    整个流程相当于随机取 5 个 key 放入 pool，然后淘汰 pool 中空闲时间最大的 key，然后再随机取 5 个 key放入 pool，继续淘汰 pool 中空闲时间最大的 key，一直持续下去。
  
    在进入淘汰前会计算出需要释放的内存大小，然后就一直循环上述流程，直至释放足够的内存。

#### 2.3.2 LFU

LFU——Least Frequently Userd，最近最少使用

LFU模式下

**redisObject的lru字段(24b)**划分为

* ldt(last decrememt time) 高16b——数据的访问时间戳

* logc(logistic counter) 低8b——访问频率，采用特殊的计数规则，同时还有**衰减机制**

  * **计数规则**
    数据每被访问一次，计算**p=counter当前的值* lfu_log_factor+1**，然后随机生成一个(0,1)的随机数r，只有p>r时，counter才+1     
    lfu_log_factor:对数因子，默认为10   

  * **衰减机制**

    使用 **配置lfu_decay_time**来控制counter的衰减

    LFU会计算当前时间和数据最近一次访问时间的差值，然后将该差值转换为以分钟为单位，然后将该差值除以 lfu_decay_time，得到的结果是counter要衰减的值

# 3. 内存优化

## 3.1 redisObject对象

Redis存储的数据都用**redisObject**来封装

```c
typedef struct redisObject{
    unsigned int type;      //4B，对象类型
    unsigned int encoding;  //4B，内部编码类型
    REDIS_LRU_BITS lru;     //24b,记录对象最后一次被访问的时间戳
    int refcount;           //引用计数器，记录当前对象被引用的次数
    void * ptr              //与对象的数据内容相关——如果是整数，直接存储数据，否则为指向数据的指针
}
```

## 3.2 共享对象池

Redis内部维护0—9999的整数对象池

如果创建0-9999的整数，直接使用整数对象池中的对象——节约内存

**如果设置了maxmemory并且开启了 volatile-lru策略 or allkeys-lru策略，那么Redis将禁用共享对象池**



## 3.3 字符串优化

### 3.3.1 字符串结构

Redis内部实现了 简单动态字符串(simple dynamic string，SDS)

```c
typedef struct SBS{
    int len;   //已用长度
    int free;  //未用长度
    char buf[];//字符数据
}
```

### 3.3.2 空间预分配机制

Redis的字符串采用了**空间预分配机制**——防止修改操作需要不断重分配内存和字节数据拷贝

* 第一次创建时，len属性=实际大小，free为0，不做预分配

* 修改后，如果已有free空间不够且数据<1MB，每次预分配一倍容量

  >原有len=60b，free=0，再追加60b，预分配120b——len=120b，free=120b

* 修改后，如果已有free空间不够且数据>1MB，每次预分配1MB容量



## 3.4 编码优化

### 3.4.1 编码类型转换

Redis在写入数据时自动进行编码类型转换

* 转换不可逆
* 转换规则：只能由小内存编码向大内存编码转换

